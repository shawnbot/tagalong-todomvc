{"version":3,"sources":["webpack:///tagalong.js","webpack:///webpack/bootstrap 6ba0cbeba1ce3bb270d2","webpack:///./src/main.js","webpack:///./~/document-register-element/build/document-register-element.js","webpack:///./src/t-template.js","webpack:///./src/property.js","webpack:///./src/evaluate.js","webpack:///./src/arrow.js","webpack:///./src/functor.js","webpack:///./src/render.js","webpack:///./src/interpolate.js","webpack:///./src/compose.js","webpack:///./src/util.js","webpack:///./src/h.js","webpack:///./src/ns.js","webpack:///./~/morphdom/lib/index.js","webpack:///./src/constants.js","webpack:///./src/attrs.js","webpack:///./src/dom.js","webpack:///./src/scope.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","Template","render","window","tagalong","createRenderer","create","e","t","n","r","rt","length","vt","it","nt","b","ot","st","j","querySelectorAll","w","getAttribute","nodeName","toUpperCase","S","y","v","d","ut","indexOf","at","currentTarget","attrChange","attrName","i","target","Q","attributeChangedCallback","prevValue","newValue","a","l","ft","X","push","lt","K","removeEventListener","h","detail","o","s","B","pt","ct","this","q","G","ht","D","et","observe","z","J","setAttribute","Z","addEventListener","createdCallback","created","F","E","contains","splice","dt","Error","tt","Y","Math","random","u","f","g","documentElement","x","prototype","T","hasOwnProperty","N","isPrototypeOf","C","defineProperty","k","getOwnPropertyDescriptor","L","getOwnPropertyNames","A","getPrototypeOf","O","setPrototypeOf","M","__proto__","_","mt","P","MutationObserver","WebKitMutationObserver","H","HTMLElement","Element","Node","nodeType","I","cloneNode","R","removeAttribute","U","createElement","attributes","characterData","attributeOldValue","W","V","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","setTimeout","$","value","CustomEvent","bubbles","dispatchEvent","hasAttribute","propertyName","name","className","type","addedNodes","removedNodes","attributeName","oldValue","childList","subtree","shift","apply","arguments","toLowerCase","innerHTMLHelper","test","concat","document","Object","property","evaluate","RENDER","DATA_ATTR","registerElement","attachedCallback","update","attr","previous","console","log","expr","data","renderTo","node","invalidate","get","read","write","defaultValue","symbol","Date","now","enumerable","set","identity","arrow","functor","expression","fn","evaluator","String","trim","undefined","is","parse","match","Function","join","ARROW_PATTERN","isArrow","parseArrow","args","body","code","interpolate","compose","morphdom","T_ID","dom","util","ns","scope","EVENTS","eventHandlerId","eventHandlersById","createTextRenderer","stringify","compile","nodeValue","createCommentRenderer","createComment","pluckEventHandlers","attrMap","handlers","substr","registerEventHandlers","index","tid","context","callback","event","bound","createElementRenderer","SKIP","getPrefixedName","getAttributeMap","condition","IF","ELSE","ifSibling","getPreviousSibling","not","renderChildren","TEXT","compileExpression","childRenderers","map","childNodes","renderChild","renderNode","attrs","interpolateAttributes","children","eachExpression","EACH","forEachExpression","FOREACH","withExpression","WITH","AS","renderEach","renderWith","symbolSetter","src","selector","querySelector","options","dest","result","updateEventHandlers","root","elements","slice","unshift","forEach","el","events","renderData","pattern","isTemplate","str","RegExp","template","that","replace","part","defined","props","Array","isArray","createDocumentFragment","qualify","namespaceURI","createElementNS","localName","setProps","append","child","appendChild","createTextNode","prop","formatClassName","formatStyle","warn","setAttributeNS","obj","keys","key","reformatCamelCase","char","filter","prefixToURI","svg","xlink","xmlns","uriToPrefix","prefix","qname","colon","empty","toElement","range","createRange","selectNode","fragment","createContextualFragment","innerHTML","noop","XHTML","morphAttrs","fromNode","toNode","attrValue","fromValue","foundAttrs","getAttributeNS","specified","removeAttributeNode","moveChildren","fromEl","toEl","curChild","firstChild","nextChild","nextSibling","defaultGetNodeKey","removeNodeHelper","nestedInSavedEl","getNodeKey","savedEls","onNodeDiscarded","ELEMENT_NODE","walkDiscardedChildNodes","removeNode","parentNode","alreadyVisited","onBeforeNodeDiscarded","removeChild","morphEl","childrenOnly","toElKey","onBeforeElUpdated","onElUpdated","onBeforeElChildrenUpdated","curToNodeId","fromNextSibling","toNextSibling","savedEl","unmatchedEl","curToNodeChild","curFromNodeChild","outer","curFromNodeId","unmatchedEls","replaceChild","curFromNodeType","isCompatible","compareNodeNames","TEXT_NODE","onBeforeNodeAdded","onNodeAdded","movedEls","specialElHandler","specialElHandlers","toNodeHtml","onBeforeMorphEl","onBeforeMorphElChildren","morphedNode","morphedNodeType","toNodeType","handleMovedEl","handleMovedElsLoop","movedElsTemp","savedElId","testEl","getAttributeNode","OPTION","selected","INPUT","checked","disabled","TEXTAREA","PREFIX","CONTROL_ATTRS","constants","T_PREFIX","previousSibling","matches","values","iterate","INDEX","each","split"],"mappings":"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","file":"tagalong.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\t\n\tvar Template = __webpack_require__(2);\n\tvar render = __webpack_require__(7);\n\t\n\twindow.tagalong = {\n\t  Template: Template,\n\t  createRenderer: render.create,\n\t  render: render.render\n\t};\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t/*! (C) WebReflection Mit Style License */\n\t(function(e,t,n,r){\"use strict\";function rt(e,t){for(var n=0,r=e.length;n<r;n++)vt(e[n],t)}function it(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],nt(r,b[ot(r)])}function st(e){return function(t){j(t)&&(vt(t,e),rt(t.querySelectorAll(w),e))}}function ot(e){var t=e.getAttribute(\"is\"),n=e.nodeName.toUpperCase(),r=S.call(y,t?v+t.toUpperCase():d+n);return t&&-1<r&&!ut(n,t)?-1:r}function ut(e,t){return-1<w.indexOf(e+'[is=\"'+t+'\"]')}function at(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,i=e.target;Q&&(!i||i===t)&&t.attributeChangedCallback&&r!==\"style\"&&e.prevValue!==e.newValue&&t.attributeChangedCallback(r,n===e[a]?null:e.prevValue,n===e[l]?null:e.newValue)}function ft(e){var t=st(e);return function(e){X.push(t,e.target)}}function lt(e){K&&(K=!1,e.currentTarget.removeEventListener(h,lt)),rt((e.target||t).querySelectorAll(w),e.detail===o?o:s),B&&pt()}function ct(e,t){var n=this;q.call(n,e,t),G.call(n,{target:n})}function ht(e,t){D(e,t),et?et.observe(e,z):(J&&(e.setAttribute=ct,e[i]=Z(e),e.addEventListener(p,G)),e.addEventListener(c,at)),e.createdCallback&&Q&&(e.created=!0,e.createdCallback(),e.created=!1)}function pt(){for(var e,t=0,n=F.length;t<n;t++)e=F[t],E.contains(e)||(n--,F.splice(t--,1),vt(e,o))}function dt(e){throw new Error(\"A \"+e+\" type is already registered\")}function vt(e,t){var n,r=ot(e);-1<r&&(tt(e,b[r]),r=0,t===s&&!e[s]?(e[o]=!1,e[s]=!0,r=1,B&&S.call(F,e)<0&&F.push(e)):t===o&&!e[o]&&(e[s]=!1,e[o]=!0,r=1),r&&(n=e[t+\"Callback\"])&&n.call(e))}if(r in t)return;var i=\"__\"+r+(Math.random()*1e5>>0),s=\"attached\",o=\"detached\",u=\"extends\",a=\"ADDITION\",f=\"MODIFICATION\",l=\"REMOVAL\",c=\"DOMAttrModified\",h=\"DOMContentLoaded\",p=\"DOMSubtreeModified\",d=\"<\",v=\"=\",m=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,g=[\"ANNOTATION-XML\",\"COLOR-PROFILE\",\"FONT-FACE\",\"FONT-FACE-SRC\",\"FONT-FACE-URI\",\"FONT-FACE-FORMAT\",\"FONT-FACE-NAME\",\"MISSING-GLYPH\"],y=[],b=[],w=\"\",E=t.documentElement,S=y.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},x=n.prototype,T=x.hasOwnProperty,N=x.isPrototypeOf,C=n.defineProperty,k=n.getOwnPropertyDescriptor,L=n.getOwnPropertyNames,A=n.getPrototypeOf,O=n.setPrototypeOf,M=!!n.__proto__,_=n.create||function mt(e){return e?(mt.prototype=e,new mt):this},D=O||(M?function(e,t){return e.__proto__=t,e}:L&&k?function(){function e(e,t){for(var n,r=L(t),i=0,s=r.length;i<s;i++)n=r[i],T.call(e,n)||C(e,n,k(t,n))}return function(t,n){do e(t,n);while((n=A(n))&&!N.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),P=e.MutationObserver||e.WebKitMutationObserver,H=(e.HTMLElement||e.Element||e.Node).prototype,B=!N.call(H,E),j=B?function(e){return e.nodeType===1}:function(e){return N.call(H,e)},F=B&&[],I=H.cloneNode,q=H.setAttribute,R=H.removeAttribute,U=t.createElement,z=P&&{attributes:!0,characterData:!0,attributeOldValue:!0},W=P||function(e){J=!1,E.removeEventListener(c,W)},X,V=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,10)},$=!1,J=!0,K=!0,Q=!0,G,Y,Z,et,tt,nt;O||M?(tt=function(e,t){N.call(t,e)||ht(e,t)},nt=ht):(tt=function(e,t){e[i]||(e[i]=n(!0),ht(e,t))},nt=tt),B?(J=!1,function(){var e=k(H,\"addEventListener\"),t=e.value,n=function(e){var t=new CustomEvent(c,{bubbles:!0});t.attrName=e,t.prevValue=this.getAttribute(e),t.newValue=null,t[l]=t.attrChange=2,R.call(this,e),this.dispatchEvent(t)},r=function(e,t){var n=this.hasAttribute(e),r=n&&this.getAttribute(e),i=new CustomEvent(c,{bubbles:!0});q.call(this,e,t),i.attrName=e,i.prevValue=n?r:null,i.newValue=t,n?i[f]=i.attrChange=1:i[a]=i.attrChange=0,this.dispatchEvent(i)},s=function(e){var t=e.currentTarget,n=t[i],r=e.propertyName,s;n.hasOwnProperty(r)&&(n=n[r],s=new CustomEvent(c,{bubbles:!0}),s.attrName=n.name,s.prevValue=n.value||null,s.newValue=n.value=t[r]||null,s.prevValue==null?s[a]=s.attrChange=0:s[f]=s.attrChange=1,t.dispatchEvent(s))};e.value=function(e,o,u){e===c&&this.attributeChangedCallback&&this.setAttribute!==r&&(this[i]={className:{name:\"class\",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,\"propertychange\",s)),t.call(this,e,o,u)},C(H,\"addEventListener\",e)}()):P||(E.addEventListener(c,W),E.setAttribute(i,1),E.removeAttribute(i),J&&(G=function(e){var t=this,n,r,s;if(t===e.target){n=t[i],t[i]=r=Z(t);for(s in r){if(!(s in n))return Y(0,t,s,n[s],r[s],a);if(r[s]!==n[s])return Y(1,t,s,n[s],r[s],f)}for(s in n)if(!(s in r))return Y(2,t,s,n[s],r[s],l)}},Y=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,at(o)},Z=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!==\"setAttribute\"&&(r[n]=t.value);return r})),t[r]=function(n,r){c=n.toUpperCase(),$||($=!0,P?(et=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new P(function(r){for(var i,s,o,u=0,a=r.length;u<a;u++)i=r[u],i.type===\"childList\"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,Q&&s.attributeChangedCallback&&i.attributeName!==\"style\"&&(o=s.getAttribute(i.attributeName),o!==i.oldValue&&s.attributeChangedCallback(i.attributeName,i.oldValue,o)))})}(st(s),st(o)),et.observe(t,{childList:!0,subtree:!0})):(X=[],V(function E(){while(X.length)X.shift().call(null,X.shift());V(E)}),t.addEventListener(\"DOMNodeInserted\",ft(s)),t.addEventListener(\"DOMNodeRemoved\",ft(o))),t.addEventListener(h,lt),t.addEventListener(\"readystatechange\",lt),t.createElement=function(e,n){var r=U.apply(t,arguments),i=\"\"+e,s=S.call(y,(n?v:d)+(n||i).toUpperCase()),o=-1<s;return n&&(r.setAttribute(\"is\",n=n.toLowerCase()),o&&(o=ut(i.toUpperCase(),n))),Q=!t.createElement.innerHTMLHelper,o&&nt(r,b[s]),r},H.cloneNode=function(e){var t=I.call(this,!!e),n=ot(t);return-1<n&&nt(t,b[n]),e&&it(t.querySelectorAll(w)),t}),-2<S.call(y,v+c)+S.call(y,d+c)&&dt(n);if(!m.test(c)||-1<S.call(g,c))throw new Error(\"The type \"+n+\" is invalid\");var i=function(){return f?t.createElement(l,c):t.createElement(l)},a=r||x,f=T.call(a,u),l=f?r[u].toUpperCase():c,c,p;return f&&-1<S.call(y,d+l)&&dt(l),p=y.push((f?v:d)+c)-1,w=w.concat(w.length?\",\":\"\",f?l+'[is=\"'+n.toLowerCase()+'\"]':l),i.prototype=b[p]=T.call(a,\"prototype\")?a.prototype:_(H),rt(t.querySelectorAll(w),s),i}})(window,document,Object,\"registerElement\");\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar property = __webpack_require__(3);\n\tvar evaluate = __webpack_require__(4).evaluate;\n\tvar createRenderer = __webpack_require__(7).create;\n\t\n\tvar RENDER = '[[t-render]]';\n\t\n\tvar DATA_ATTR = 'data';\n\t\n\tvar Template = document.registerElement('t-template', {\n\t  prototype: Object.create(\n\t    HTMLElement.prototype,\n\t    {\n\t      attachedCallback: {value: function() {\n\t        this.update();\n\t      }},\n\t\n\t      // eslint-disable-next-line no-unused-vars\n\t      attributeChangedCallback: {value: function(attr, value, previous) {\n\t        switch (attr) {\n\t          case DATA_ATTR:\n\t            this.update();\n\t            break;\n\t          default:\n\t            return;\n\t        }\n\t      }},\n\t\n\t      update: {value: function() {\n\t        console.log('updating...');\n\t        if (this.hasAttribute(DATA_ATTR)) {\n\t          var expr = this.getAttribute(DATA_ATTR);\n\t          var data = evaluate(expr);\n\t          console.log('setting data: (', expr, ') ->', data);\n\t          this.data = data;\n\t        }\n\t      }},\n\t\n\t      /**\n\t       * @param {Object?} data\n\t       */\n\t      render: {value: function(data) {\n\t        if (!arguments.length) {\n\t          data = this.data;\n\t        }\n\t\n\t        var render = this[RENDER];\n\t        if (!render) {\n\t          render = this[RENDER] = createRenderer(this);\n\t        }\n\t\n\t        render(data);\n\t        return data;\n\t      }},\n\t\n\t      /**\n\t       * @param {Element} node\n\t       * @param {Object?} data\n\t       */\n\t      renderTo: {value: function(node, data) {\n\t        if (arguments.length < 2) {\n\t          data = this.data;\n\t        }\n\t\n\t        var render = this[RENDER];\n\t        if (!render) {\n\t          render = this[RENDER] = createRenderer(this);\n\t        }\n\t        render(node, data);\n\t        return data;\n\t      }},\n\t\n\t      /**\n\t       * Invalidate this element's compiled template, so that it\n\t       * will be recompiled on the next render.\n\t       */\n\t      invalidate: {value: function() {\n\t        this[RENDER] = null;\n\t      }},\n\t\n\t      /**\n\t       * Returns the element's bound data.\n\t       */\n\t      data: property(\n\t        function readTemplateData(data) {\n\t          return data;\n\t        },\n\t        // eslint-disable-next-line no-unused-vars\n\t        function setTemplateData(data, previous) {\n\t          return this.render(data);\n\t        },\n\t        {}\n\t      )\n\t    }\n\t  )\n\t});\n\t\n\t// only listen for changes to the data attribute\n\tObject.defineProperty(Template, 'observedAttributes', {\n\t  get: function() {\n\t    return [DATA_ATTR];\n\t  }\n\t});\n\t\n\tmodule.exports = Template;\n\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function property(read, write, defaultValue) {\n\t  var symbol = '[[t-' + Date.now() + ']]';\n\t  return {\n\t    enumerable: false,\n\t\n\t    get: function() {\n\t      var value = (symbol in this)\n\t        ? this[symbol]\n\t        : this[symbol] = defaultValue;\n\t      return read\n\t        ? read.call(this, value)\n\t        : value;\n\t    },\n\t\n\t    set: function(value) {\n\t      var previous = this[symbol];\n\t      if (value !== previous) {\n\t        // eslint-disable-next-line no-return-assign\n\t        return this[symbol] = write.call(this, value, previous);\n\t      }\n\t      return undefined;\n\t    }\n\t  };\n\t};\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* eslint no-new-func: \"warn\" */\n\tvar arrow = __webpack_require__(5);\n\tvar functor = __webpack_require__(6);\n\t\n\tvar evaluate = function(expression, data) {\n\t  var fn = evaluator(expression);\n\t  return fn.call(this, data);\n\t};\n\t\n\tvar evaluator = function(expression) {\n\t  if (typeof expression !== 'string') {\n\t    expression = String(expression);\n\t  }\n\t\n\t  if (!expression.trim()) {\n\t    return functor(undefined);\n\t  }\n\t\n\t  if (arrow.is(expression)) {\n\t    return arrow.parse(expression);\n\t  }\n\t\n\t  var symbol = 'd';\n\t  // '.' is just the identity function\n\t  if (expression.match(/^\\s*\\.\\s*$/)) {\n\t    return identity;\n\t  // '.foo' addresses the context directly\n\t  } else if (expression.match(/^\\s*\\.\\w/)) {\n\t    expression = symbol + expression;\n\t  }\n\t  return new Function(symbol, [\n\t    // 'console.info(\"', symbol, ' = \", ', symbol, ', \"', expression, '\"); ',\n\t    'try { ',\n\t    '  with (this) {',\n\t    '    with (', symbol, ') {',\n\t    '      return (', expression, ');',\n\t    '    } ',\n\t    '  } ',\n\t    '} catch (error) { }'\n\t  ].join('\\n'));\n\t};\n\t\n\tmodule.exports = {\n\t  evaluate: evaluate,\n\t  evaluator: evaluator\n\t};\n\t\n\tfunction identity(d) {\n\t  return d;\n\t}\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t/* eslint no-new-func: \"warn\" */\n\tvar ARROW_PATTERN = /^\\s*\\(?(\\s*\\w+\\s*(,\\s*\\w+\\s*)*)?\\)?\\s*=>\\s*({([^}]+)}|(.+))$/;\n\t\n\tvar isArrow = function(expression) {\n\t  return String(expression).match(ARROW_PATTERN);\n\t};\n\t\n\tvar parseArrow = function parseArrow(expression) {\n\t  var match = expression.match(ARROW_PATTERN);\n\t  if (!match) throw new Error('invalid arrow expression: \"' + expression + '\"');\n\t  var args = match[1];\n\t  var body = (match[4] || match[5]).trim() || 'undefined';\n\t  return new Function(args, [\n\t    'with (this) {',\n\t    ' return ', body, '; ',\n\t    '}',\n\t  ].join(''));\n\t};\n\t\n\tmodule.exports = {\n\t  is: isArrow,\n\t  parse: parseArrow\n\t};\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\tmodule.exports = function functor(x) {\n\t  return function f() {\n\t    return x;\n\t  };\n\t};\n\t\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar code = __webpack_require__(4);\n\tvar interpolate = __webpack_require__(8);\n\tvar compose = __webpack_require__(9);\n\tvar h = __webpack_require__(11);\n\t\n\tvar morphdom = __webpack_require__(13);\n\t\n\tvar T = __webpack_require__(14).T;\n\tvar T_ID = 't-id';\n\tvar attr = __webpack_require__(15);\n\tvar dom = __webpack_require__(16);\n\tvar util = __webpack_require__(10);\n\tvar ns = __webpack_require__(12);\n\tvar scope = __webpack_require__(17);\n\t\n\t// this is our symbol on which we stash registered event handlers, so that\n\t// we can remove any registered handlers before adding new ones.\n\tvar EVENTS = '[[t-events]]';\n\t\n\t// we stash unique event handler ids and handlers by id, each bound to the\n\t// renered template data\n\tvar eventHandlerId = 0;\n\tvar eventHandlersById = {};\n\t\n\t/**\n\t * Returns a function that generates an interpolated string for the\n\t * given text node (`node.nodeType === Node.TEXT_NODE`).\n\t *\n\t * @param {Node} node\n\t * @return {Function} function(data:Object):String\n\t */\n\tvar createTextRenderer = function(node) {\n\t  return compose.stringify(interpolate.compile(node.nodeValue));\n\t};\n\t\n\tvar createCommentRenderer = function(node) {\n\t  var value = compose.stringify(interpolate.compile(node.nodeValue));\n\t  return function() {\n\t    return document.createComment(value.apply(this, arguments));\n\t  };\n\t};\n\t\n\t/**\n\t * \"Pluck\" event handlers from an attribute map, removing them from\n\t * the map. If no event handlers are found, the return value is\n\t * `undefined`.\n\t *\n\t * @param {Object} attrMap\n\t * @return {Object}\n\t */\n\tvar pluckEventHandlers = function(attrMap) {\n\t  var handlers = undefined;\n\t  for (var name in attrMap) {\n\t    var value = attrMap[name];\n\t    if (name.indexOf('on') === 0 && typeof value === 'function') {\n\t      if (!handlers) {\n\t        handlers = {};\n\t      }\n\t      handlers[name.substr(2)] = value;\n\t      delete attrMap[name];\n\t    }\n\t  }\n\t  return handlers;\n\t};\n\t\n\t/**\n\t * This function returns a node rendering wrapper that registers event handlers\n\t * for the rendered node by assigning it a unique `t-id` attribute and stashing\n\t * a reference to the data-bound handlers in a corresponding hash. After the\n\t * tree is morphed, each element with a `t-id` attribute is then matched up\n\t * with its event handlers.\n\t *\n\t * @param {Function} render\n\t * @param {Object} handlers each key is an event type, and the value is a\n\t * callback function.\n\t * @return {Function} a function that returns the rendered node\n\t */\n\tvar registerEventHandlers = function(render, handlers) {\n\t  return function(data, index) {\n\t    var node = render.apply(this, arguments);\n\t    if (node) {\n\t      var tid = ++eventHandlerId;\n\t      node.setAttribute(T_ID, tid);\n\t      var context = this;\n\t      var callback = function(event) {\n\t        // XXX in theory, this could fail if one\n\t        // of the handlers gets removed (not\n\t        // sure how that would happen, though)\n\t        handlers[event.type].call(context, data, event);\n\t      };\n\t      var bound = {};\n\t      for (var type in handlers) {\n\t        bound[type] = callback;\n\t      }\n\t      eventHandlersById[tid] = bound;\n\t    }\n\t    return node;\n\t  };\n\t};\n\t\n\t/**\n\t * Returns a function that generates an interpolated DOM element tree\n\t * for the given element node\n\t * (`node.nodeType === Node.ELEMENT_NODE`).\n\t *\n\t * @param {Element} node\n\t * @return {Function} function(data:Object):Element\n\t */\n\tvar createElementRenderer = function(node) {\n\t  // this element will never be rendered if it has a truthy t-skip\n\t  // attribute\n\t  if (node.hasAttribute(T.SKIP)) {\n\t    return undefined;\n\t  }\n\t\n\t  var name = ns.getPrefixedName(node);\n\t  var attrMap = attr.getAttributeMap(node);\n\t  var handlers = pluckEventHandlers(attrMap);\n\t\n\t  var condition = node.hasAttribute(T.IF)\n\t    ? code.evaluator(node.getAttribute(T.IF))\n\t    : undefined;\n\t\n\t  if (node.hasAttribute(T.ELSE)) {\n\t    if (condition) {\n\t      throw new Error('element has both t-if and t-else attributes');\n\t    }\n\t    // TODO: ELSEIF should just collect all of the previous IF and\n\t    // ELSEIF nodes and negate them. Some checking should happen here to\n\t    // ensure that they're specified in the correct order.\n\t    var ifSibling = dom.getPreviousSibling(node, '[' + T.IF + ']');\n\t    if (!ifSibling) {\n\t      throw new Error('element with t-else has no matching t-if sibling');\n\t    }\n\t    condition = compose.not(code.evaluator(ifSibling.getAttribute(T.IF)));\n\t  }\n\t\n\t  var renderChildren;\n\t\n\t  // <span t-text=\"some.value\"></span>\n\t  if (node.hasAttribute(T.TEXT)) {\n\t    renderChildren = compose.stringify(\n\t      util.compileExpression(node.getAttribute(T.TEXT))\n\t    );\n\t  } else {\n\t    var childRenderers = [].map.call(node.childNodes, compile);\n\t    renderChildren = function(data) {\n\t      return childRenderers.map(function(renderChild, i) {\n\t        return (typeof renderChild === 'function')\n\t          ? renderChild.call(this, data)\n\t          : renderChild;\n\t      }, this);\n\t    };\n\t  }\n\t\n\t  var renderNode = function(data) {\n\t    if (condition && !condition.call(this, data)) {\n\t      return undefined;\n\t    }\n\t\n\t    var attrs = attr.interpolateAttributes.call(this, attrMap, data);\n\t    var children = renderChildren.call(this, data);\n\t    return h(name, attrs, children);\n\t  };\n\t\n\t  // \"attach\" (as a single property) the event handler maps\n\t  if (handlers) {\n\t    renderNode = registerEventHandlers(renderNode, handlers);\n\t  }\n\t\n\t  var eachExpression = node.getAttribute(T.EACH);\n\t  var forEachExpression = node.getAttribute(T.FOREACH);\n\t  var withExpression = node.getAttribute(T.WITH);\n\t\n\t  var symbol = node.getAttribute(T.AS);\n\t\n\t  if (eachExpression) {\n\t    renderNode = scope.renderEach(\n\t      code.evaluator(eachExpression),\n\t      renderNode,\n\t      symbol\n\t    );\n\t  } else if (forEachExpression) {\n\t    renderChildren = scope.renderEach(\n\t      code.evaluator(forEachExpression),\n\t      renderChildren,\n\t      symbol\n\t    );\n\t  } else if (withExpression) {\n\t    renderNode = scope.renderWith(\n\t      code.evaluator(withExpression),\n\t      renderNode,\n\t      symbol\n\t    );\n\t  } else if (symbol) {\n\t    renderNode = scope.symbolSetter(symbol, renderNode);\n\t  }\n\t\n\t  return renderNode;\n\t};\n\t\n\t/**\n\t * Returns a rendering function for a given source (\"template\") node\n\t * and optional variable context for expressions.\n\t *\n\t * The returned function has the signatures:\n\t *\n\t * function(data:*)\n\t * function(node:Node, data:*)\n\t *\n\t * Where `data` is expected to be an object and, in the second form,\n\t * `node` is a target node to which the diffed DOM should be applied.\n\t *\n\t * @param {Node}    src\n\t * @param {Object?} context\n\t * @return {Function}\n\t */\n\tvar createRenderer = function(src, context) {\n\t  if (typeof src === 'string') {\n\t    var selector = src;\n\t    src = document.querySelector(src);\n\t    if (!src) {\n\t      throw new Error('no element found with selector: \"' + selector + '\"');\n\t    }\n\t  }\n\t\n\t  var renderNode = compile(src);\n\t  return function(node, data, options) {\n\t    if (arguments.length < 2) {\n\t      data = node;\n\t    }\n\t    if ((!node && data) || node === data) {\n\t      node = src;\n\t    }\n\t    eventHandlerId = 0;\n\t    eventHandlersById = {};\n\t    var dest = renderNode.call(context, data);\n\t    var result = morphdom(src, dest, options);\n\t    updateEventHandlers(result);\n\t    return result;\n\t  };\n\t};\n\t\n\t/**\n\t * Update all of the event handlers in the given DOM tree. This looks for all\n\t * elements with the `t-id` attribute (including the root), removes any\n\t * existing handlers (stashed in the `[[t-events]]` symbol), then looks up the\n\t * registered handlers for the corresponding `t-id` value and adds those.\n\t *\n\t * @param {Element} root\n\t */\n\tvar updateEventHandlers = function(root) {\n\t  var elements = [].slice.call(root.querySelectorAll('[' + T_ID + ']'));\n\t  if (root.hasAttribute(T_ID)) {\n\t    elements.unshift(root);\n\t  }\n\t  elements.forEach(function(el) {\n\t    var events = el[EVENTS];\n\t    var type;\n\t    if (events) {\n\t      for (type in events) {\n\t        el.removeEventListener(type, events[type], true);\n\t        delete events[type];\n\t      }\n\t      delete el[EVENTS];\n\t    }\n\t    var tid = el.getAttribute(T_ID);\n\t    events = eventHandlersById[tid];\n\t    if (events) {\n\t      for (type in events) {\n\t        el.addEventListener(type, events[type], true);\n\t      }\n\t      el[EVENTS] = events;\n\t    }\n\t    el.removeAttribute(T_ID);\n\t  });\n\t};\n\t\n\t/**\n\t * Creates a renderer, renders once if data is provided, and returns\n\t * a bound rendering function for subsequent calling.\n\t *\n\t * @param {Node}    src\n\t * @param {Object?} context\n\t * @return {Function}\n\t */\n\tvar render = function(src, data, context) {\n\t  var renderData = createRenderer(src, context);\n\t  if (data) {\n\t    renderData(src, data);\n\t  }\n\t  return renderData;\n\t};\n\t\n\t/**\n\t * Returns a DOM element rendering function for the given \"template\"\n\t * or source node. This may be publicly exposed if it becomes useful,\n\t * e.g. for composition of referenced templates.\n\t *\n\t * @param {Node} node\n\t * @return {Function} the returned function takes data and returns an\n\t * unattached Node instance: function(data:Object):Node\n\t */\n\tvar compile = function(node) {\n\t  switch (node.nodeType) {\n\t    case 1: // Node.ELEMENT_NODE\n\t      return createElementRenderer(node);\n\t\n\t    case 3: // Node.TEXT_NODE\n\t      return createTextRenderer(node);\n\t\n\t    case 8: // Node.COMMENT_NODE\n\t      return createCommentRenderer(node);\n\t\n\t    // TODO: support document fragments?\n\t    // this would need support in h()\n\t\n\t    default:\n\t      throw new Error('no renderer for node type: ' + node.nodeType);\n\t  }\n\t};\n\t\n\t\n\tmodule.exports.render = render;\n\tmodule.exports.createRenderer = createRenderer;\n\tmodule.exports.compile = compile;\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar evaluate = __webpack_require__(4).evaluate;\n\tvar functor = __webpack_require__(6);\n\t\n\tvar pattern = /{{\\s*([^}]+)\\s*}}/g;\n\t\n\tvar isTemplate = function(str) {\n\t  return new RegExp(pattern).test(str);\n\t};\n\t\n\tvar compile = function(template) {\n\t  if (typeof template !== 'string') {\n\t    throw new Error('interpolate.compile() expected a string;' +\n\t                    'got ' + (typeof template));\n\t  }\n\t\n\t  if (!isTemplate(template)) {\n\t    return functor(template);\n\t  }\n\t\n\t  return function(data) {\n\t    var that = this;\n\t    return template.replace(pattern, function(_, part) {\n\t      return evaluate.call(that, part, data);\n\t    });\n\t  };\n\t};\n\t\n\tvar interpolate = function interpolate(str, data) {\n\t  return compile(str).call(this, data);\n\t};\n\t\n\tmodule.exports = interpolate;\n\t\n\tmodule.exports.isTemplate = isTemplate;\n\t\n\tmodule.exports.compile = compile;\n\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/**\n\t * functional composition functions take a function and return a\n\t * wrapped function that calls the passed one and applies some\n\t * additional logic.\n\t */\n\t\n\tvar defined = __webpack_require__(10).defined;\n\t\n\t/**\n\t * @param {Function}  fn\n\t * @return {Function} a function that returns the inverse (`!`)\n\t *                    value of the `fn`, given the same arguments.\n\t */\n\tmodule.exports.not = function(fn) {\n\t  return function() {\n\t    return !fn.apply(this, arguments);\n\t  };\n\t};\n\t\n\t/**\n\t * @param {Function}  fn\n\t * @return {Function} a function that returns the stringified\n\t *                    value of the `fn`, given the same arguments.\n\t */\n\tmodule.exports.stringify = function(fn) {\n\t  return function() {\n\t    var value = fn.apply(this, arguments);\n\t    return defined(value) ? String(value) : '';\n\t  };\n\t};\n\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar code = __webpack_require__(4);\n\tvar interpolate = __webpack_require__(8);\n\t\n\tmodule.exports.defined = function(value) {\n\t  return value !== null && value !== undefined;\n\t};\n\t\n\tmodule.exports.compileExpression = function(expr) {\n\t  return interpolate.isTemplate(expr)\n\t    ? interpolate.compile(expr)\n\t    : code.evaluator(expr);\n\t};\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar ns = __webpack_require__(12);\n\t\n\tmodule.exports = function(name, props, children) {\n\t  var node;\n\t  if (Array.isArray(name)) {\n\t    node = document.createDocumentFragment();\n\t  } else {\n\t    name = ns.qualify(name);\n\t    node = name.namespaceURI\n\t      ? document.createElementNS(name.namespaceURI, name.localName)\n\t      : document.createElement(name.localName);\n\t  }\n\t\n\t  if (Array.isArray(props) || typeof props === 'string') {\n\t    children = props;\n\t  } else if (typeof props === 'object') {\n\t    setProps(node, props);\n\t  }\n\t\n\t  var append = function(child) {\n\t    if (Array.isArray(child)) {\n\t      child.forEach(append);\n\t    } else if (typeof child === 'object') {\n\t      node.appendChild(child);\n\t    } else if (typeof child === 'string') {\n\t      node.appendChild(document.createTextNode(child));\n\t    }\n\t  };\n\t\n\t  if (typeof children === 'object' || typeof children === 'string') {\n\t    append(children);\n\t  }\n\t\n\t  return node;\n\t};\n\t\n\tvar setProps = function(el, props) {\n\t  for (var prop in props) {\n\t    if (!props.hasOwnProperty(prop)) {\n\t      continue;\n\t    }\n\t    var value = props[prop];\n\t    if (value === null || value === undefined || typeof value === 'function') {\n\t      // XXX: don't add null, undefined, or function values\n\t      continue;\n\t    } else if (typeof value === 'object') {\n\t      switch (prop) {\n\t        case 'class':\n\t          value = formatClassName(value);\n\t          break;\n\t\n\t        case 'style':\n\t          value = formatStyle(value);\n\t          break;\n\t\n\t        default:\n\t          console.warn('unrecognized object prop:', prop, value);\n\t          continue;\n\t      }\n\t    }\n\t\n\t    var name = ns.qualify(prop);\n\t    if (name.namespaceURI) {\n\t      el.setAttributeNS(name.namespaceURI, name.name, value);\n\t    } else {\n\t      el.setAttribute(name.localName, value);\n\t    }\n\t  }\n\t};\n\t\n\tvar formatStyle = function(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return obj.join('; ');\n\t  }\n\t  return Object.keys(obj)\n\t    .map(function(key) {\n\t      return [\n\t        reformatCamelCase(key),\n\t        ': ',\n\t        obj[key],\n\t        ';'\n\t      ].join('');\n\t    })\n\t    .join(' ');\n\t};\n\t\n\tvar reformatCamelCase = function(str) {\n\t  return str.replace(/[A-Z]/g, function(char) {\n\t    return '-' + char.toLowerCase();\n\t  });\n\t};\n\t\n\tvar formatClassName = function(obj) {\n\t  if (Array.isArray(obj)) {\n\t    return obj.join(' ');\n\t  }\n\t  return Object.keys(obj).filter(function(key) {\n\t    return !!obj[key];\n\t  }).join(' ');\n\t};\n\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\tvar prefixToURI = {\n\t  svg: 'http://www.w3.org/2000/svg',\n\t  xlink: 'http://www.w3.org/TR/xlink/',\n\t  xmlns: 'http://www.w3.org/2000/xmlns/'\n\t};\n\t\n\tvar uriToPrefix = {};\n\tObject.keys(prefixToURI).forEach(function(prefix) {\n\t  uriToPrefix[prefixToURI[prefix]] = prefix;\n\t});\n\t\n\tvar qualify = function(qname) {\n\t  var prefix;\n\t  var localName = qname;\n\t  var colon = qname.indexOf(':');\n\t  if (colon > -1) {\n\t    prefix = qname.substr(0, colon);\n\t    localName = qname.substr(colon + 1);\n\t  }\n\t  return {\n\t    name: qname,\n\t    localName: localName,\n\t    prefix: prefix,\n\t    namespaceURI: prefixToURI[prefix]\n\t  };\n\t};\n\t\n\tvar getPrefixedName = function(node) {\n\t  var name = node.nodeName.toLowerCase();\n\t  var prefix = node.prefix;\n\t  if (!prefix && node.namespaceURI) {\n\t    prefix = uriToPrefix[node.namespaceURI];\n\t  }\n\t  return prefix\n\t    ? (prefix + ':' + name)\n\t    : name;\n\t};\n\t\n\tmodule.exports = {\n\t  getPrefixedName: getPrefixedName,\n\t  prefixToURI: prefixToURI,\n\t  uriToPrefix: uriToPrefix,\n\t  qualify: qualify\n\t};\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t// Create a range object for efficently rendering strings to elements.\n\tvar range;\n\t\n\tvar testEl = (typeof document !== 'undefined') ?\n\t    document.body || document.createElement('div') :\n\t    {};\n\t\n\tvar XHTML = 'http://www.w3.org/1999/xhtml';\n\t\n\t// Fixes <https://github.com/patrick-steele-idem/morphdom/issues/32>\n\t// (IE7+ support) <=IE7 does not support el.hasAttribute(name)\n\tvar hasAttribute;\n\tif (testEl.hasAttribute) {\n\t    hasAttribute = function hasAttribute(el, name) {\n\t        return el.hasAttribute(name);\n\t    };\n\t} else {\n\t    hasAttribute = function hasAttribute(el, name) {\n\t        return !!el.getAttributeNode(name);\n\t    };\n\t}\n\t\n\tfunction empty(o) {\n\t    for (var k in o) {\n\t        if (o.hasOwnProperty(k)) {\n\t            return false;\n\t        }\n\t    }\n\t    return true;\n\t}\n\t\n\tfunction toElement(str) {\n\t    if (!range && document.createRange) {\n\t        range = document.createRange();\n\t        range.selectNode(document.body);\n\t    }\n\t\n\t    var fragment;\n\t    if (range && range.createContextualFragment) {\n\t        fragment = range.createContextualFragment(str);\n\t    } else {\n\t        fragment = document.createElement('body');\n\t        fragment.innerHTML = str;\n\t    }\n\t    return fragment.childNodes[0];\n\t}\n\t\n\tvar specialElHandlers = {\n\t    /**\n\t     * Needed for IE. Apparently IE doesn't think that \"selected\" is an\n\t     * attribute when reading over the attributes using selectEl.attributes\n\t     */\n\t    OPTION: function(fromEl, toEl) {\n\t        fromEl.selected = toEl.selected;\n\t        if (fromEl.selected) {\n\t            fromEl.setAttribute('selected', '');\n\t        } else {\n\t            fromEl.removeAttribute('selected', '');\n\t        }\n\t    },\n\t    /**\n\t     * The \"value\" attribute is special for the <input> element since it sets\n\t     * the initial value. Changing the \"value\" attribute without changing the\n\t     * \"value\" property will have no effect since it is only used to the set the\n\t     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n\t     */\n\t    INPUT: function(fromEl, toEl) {\n\t        fromEl.checked = toEl.checked;\n\t        if (fromEl.checked) {\n\t            fromEl.setAttribute('checked', '');\n\t        } else {\n\t            fromEl.removeAttribute('checked');\n\t        }\n\t\n\t        if (fromEl.value !== toEl.value) {\n\t            fromEl.value = toEl.value;\n\t        }\n\t\n\t        if (!hasAttribute(toEl, 'value')) {\n\t            fromEl.removeAttribute('value');\n\t        }\n\t\n\t        fromEl.disabled = toEl.disabled;\n\t        if (fromEl.disabled) {\n\t            fromEl.setAttribute('disabled', '');\n\t        } else {\n\t            fromEl.removeAttribute('disabled');\n\t        }\n\t    },\n\t\n\t    TEXTAREA: function(fromEl, toEl) {\n\t        var newValue = toEl.value;\n\t        if (fromEl.value !== newValue) {\n\t            fromEl.value = newValue;\n\t        }\n\t\n\t        if (fromEl.firstChild) {\n\t            fromEl.firstChild.nodeValue = newValue;\n\t        }\n\t    }\n\t};\n\t\n\tfunction noop() {}\n\t\n\t/**\n\t * Returns true if two node's names and namespace URIs are the same.\n\t *\n\t * @param {Element} a\n\t * @param {Element} b\n\t * @return {boolean}\n\t */\n\tvar compareNodeNames = function(a, b) {\n\t    return a.nodeName === b.nodeName &&\n\t           a.namespaceURI === b.namespaceURI;\n\t};\n\t\n\t/**\n\t * Create an element, optionally with a known namespace URI.\n\t *\n\t * @param {string} name the element name, e.g. 'div' or 'svg'\n\t * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n\t * its `xmlns` attribute or its inferred namespace.\n\t *\n\t * @return {Element}\n\t */\n\tfunction createElement(name, namespaceURI) {\n\t    return (namespaceURI && namespaceURI !== XHTML) ?\n\t        document.createElementNS(namespaceURI, name) :\n\t        document.createElement(name);\n\t}\n\t\n\t/**\n\t * Loop over all of the attributes on the target node and make sure the original\n\t * DOM node has the same attributes. If an attribute found on the original node\n\t * is not on the new node then remove it from the original node.\n\t *\n\t * @param  {Element} fromNode\n\t * @param  {Element} toNode\n\t */\n\tfunction morphAttrs(fromNode, toNode) {\n\t    var attrs = toNode.attributes;\n\t    var i;\n\t    var attr;\n\t    var attrName;\n\t    var attrValue;\n\t    var foundAttrs = {};\n\t    var fromValue;\n\t\n\t    for (i = attrs.length - 1; i >= 0; i--) {\n\t        attr = attrs[i];\n\t        attrName = attr.name;\n\t        attrValue = attr.value;\n\t        fromValue = fromNode.getAttributeNS(attr.namespaceURI, attr.name);\n\t        foundAttrs[attrName] = true;\n\t\n\t        if (fromValue !== attrValue) {\n\t            fromNode.setAttributeNS(\n\t              attr.namespaceURI,\n\t              attr.name,\n\t              attrValue\n\t            );\n\t        }\n\t    }\n\t\n\t    // Remove any extra attributes found on the original DOM element that\n\t    // weren't found on the target element.\n\t    attrs = fromNode.attributes;\n\t\n\t    for (i = attrs.length - 1; i >= 0; i--) {\n\t        attr = attrs[i];\n\t        if (attr.specified !== false) {\n\t            attrName = attr.name;\n\t            if (!foundAttrs.hasOwnProperty(attrName)) {\n\t                fromNode.removeAttributeNode(attr);\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\t/**\n\t * Copies the children of one DOM element to another DOM element\n\t */\n\tfunction moveChildren(fromEl, toEl) {\n\t    var curChild = fromEl.firstChild;\n\t    while (curChild) {\n\t        var nextChild = curChild.nextSibling;\n\t        toEl.appendChild(curChild);\n\t        curChild = nextChild;\n\t    }\n\t    return toEl;\n\t}\n\t\n\tfunction defaultGetNodeKey(node) {\n\t    return node.id;\n\t}\n\t\n\tfunction morphdom(fromNode, toNode, options) {\n\t    if (!options) {\n\t        options = {};\n\t    }\n\t\n\t    if (typeof toNode === 'string') {\n\t        if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {\n\t            var toNodeHtml = toNode;\n\t            toNode = document.createElement('html');\n\t            toNode.innerHTML = toNodeHtml;\n\t        } else {\n\t            toNode = toElement(toNode);\n\t        }\n\t    }\n\t\n\t    // XXX optimization: if the nodes are equal, don't morph them\n\t    /*\n\t    if (fromNode.isEqualNode(toNode)) {\n\t      return fromNode;\n\t    }\n\t    */\n\t\n\t    var savedEls = {}; // Used to save off DOM elements with IDs\n\t    var unmatchedEls = {};\n\t    var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n\t    var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n\t    var onNodeAdded = options.onNodeAdded || noop;\n\t    var onBeforeElUpdated = options.onBeforeElUpdated || options.onBeforeMorphEl || noop;\n\t    var onElUpdated = options.onElUpdated || noop;\n\t    var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n\t    var onNodeDiscarded = options.onNodeDiscarded || noop;\n\t    var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || options.onBeforeMorphElChildren || noop;\n\t    var childrenOnly = options.childrenOnly === true;\n\t    var movedEls = [];\n\t\n\t    function removeNodeHelper(node, nestedInSavedEl) {\n\t        var id = getNodeKey(node);\n\t        // If the node has an ID then save it off since we will want\n\t        // to reuse it in case the target DOM tree has a DOM element\n\t        // with the same ID\n\t        if (id) {\n\t            savedEls[id] = node;\n\t        } else if (!nestedInSavedEl) {\n\t            // If we are not nested in a saved element then we know that this node has been\n\t            // completely discarded and will not exist in the final DOM.\n\t            onNodeDiscarded(node);\n\t        }\n\t\n\t        if (node.nodeType === Node.ELEMENT_NODE) {\n\t            var curChild = node.firstChild;\n\t            while (curChild) {\n\t                removeNodeHelper(curChild, nestedInSavedEl || id);\n\t                curChild = curChild.nextSibling;\n\t            }\n\t        }\n\t    }\n\t\n\t    function walkDiscardedChildNodes(node) {\n\t        if (node.nodeType === Node.ELEMENT_NODE) {\n\t            var curChild = node.firstChild;\n\t            while (curChild) {\n\t\n\t\n\t                if (!getNodeKey(curChild)) {\n\t                    // We only want to handle nodes that don't have an ID to avoid double\n\t                    // walking the same saved element.\n\t\n\t                    onNodeDiscarded(curChild);\n\t\n\t                    // Walk recursively\n\t                    walkDiscardedChildNodes(curChild);\n\t                }\n\t\n\t                curChild = curChild.nextSibling;\n\t            }\n\t        }\n\t    }\n\t\n\t    function removeNode(node, parentNode, alreadyVisited) {\n\t        if (onBeforeNodeDiscarded(node) === false) {\n\t            return;\n\t        }\n\t\n\t        parentNode.removeChild(node);\n\t        if (alreadyVisited) {\n\t            if (!getNodeKey(node)) {\n\t                onNodeDiscarded(node);\n\t                walkDiscardedChildNodes(node);\n\t            }\n\t        } else {\n\t            removeNodeHelper(node);\n\t        }\n\t    }\n\t\n\t    function morphEl(fromEl, toEl, alreadyVisited, childrenOnly) {\n\t        var toElKey = getNodeKey(toEl);\n\t        if (toElKey) {\n\t            // If an element with an ID is being morphed then it is will be in the final\n\t            // DOM so clear it out of the saved elements collection\n\t            delete savedEls[toElKey];\n\t        }\n\t\n\t        if (!childrenOnly) {\n\t            if (onBeforeElUpdated(fromEl, toEl) === false) {\n\t                return;\n\t            }\n\t\n\t            morphAttrs(fromEl, toEl);\n\t            onElUpdated(fromEl);\n\t\n\t            if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n\t                return;\n\t            }\n\t        }\n\t\n\t        if (fromEl.nodeName !== 'TEXTAREA') {\n\t            var curToNodeChild = toEl.firstChild;\n\t            var curFromNodeChild = fromEl.firstChild;\n\t            var curToNodeId;\n\t\n\t            var fromNextSibling;\n\t            var toNextSibling;\n\t            var savedEl;\n\t            var unmatchedEl;\n\t\n\t            outer: while (curToNodeChild) {\n\t                toNextSibling = curToNodeChild.nextSibling;\n\t                curToNodeId = getNodeKey(curToNodeChild);\n\t\n\t                while (curFromNodeChild) {\n\t                    var curFromNodeId = getNodeKey(curFromNodeChild);\n\t                    fromNextSibling = curFromNodeChild.nextSibling;\n\t\n\t                    if (!alreadyVisited) {\n\t                        if (curFromNodeId && (unmatchedEl = unmatchedEls[curFromNodeId])) {\n\t                            unmatchedEl.parentNode.replaceChild(curFromNodeChild, unmatchedEl);\n\t                            morphEl(curFromNodeChild, unmatchedEl, alreadyVisited);\n\t                            curFromNodeChild = fromNextSibling;\n\t                            continue;\n\t                        }\n\t                    }\n\t\n\t                    var curFromNodeType = curFromNodeChild.nodeType;\n\t\n\t                    if (curFromNodeType === curToNodeChild.nodeType) {\n\t                        var isCompatible = false;\n\t\n\t                        // Both nodes being compared are Element nodes\n\t                        if (curFromNodeType === Node.ELEMENT_NODE) {\n\t                            if (compareNodeNames(curFromNodeChild, curToNodeChild)) {\n\t                                // We have compatible DOM elements\n\t                                if (curFromNodeId || curToNodeId) {\n\t                                    // If either DOM element has an ID then we\n\t                                    // handle those differently since we want to\n\t                                    // match up by ID\n\t                                    if (curToNodeId === curFromNodeId) {\n\t                                        isCompatible = true;\n\t                                    }\n\t                                } else {\n\t                                    isCompatible = true;\n\t                                }\n\t                            }\n\t\n\t                            if (isCompatible) {\n\t                                // We found compatible DOM elements so transform\n\t                                // the current \"from\" node to match the current\n\t                                // target DOM node.\n\t                                morphEl(curFromNodeChild, curToNodeChild, alreadyVisited);\n\t                            }\n\t                        // Both nodes being compared are Text nodes\n\t                        } else if (curFromNodeType === Node.TEXT_NODE) {\n\t                            isCompatible = true;\n\t                            // Simply update nodeValue on the original node to\n\t                            // change the text value\n\t                            curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n\t                        }\n\t\n\t                        if (isCompatible) {\n\t                            curToNodeChild = toNextSibling;\n\t                            curFromNodeChild = fromNextSibling;\n\t                            continue outer;\n\t                        }\n\t                    }\n\t\n\t                    // No compatible match so remove the old node from the DOM\n\t                    // and continue trying to find a match in the original DOM\n\t                    removeNode(curFromNodeChild, fromEl, alreadyVisited);\n\t                    curFromNodeChild = fromNextSibling;\n\t                }\n\t\n\t                if (curToNodeId) {\n\t                    if ((savedEl = savedEls[curToNodeId])) {\n\t                        morphEl(savedEl, curToNodeChild, true);\n\t                        // We want to append the saved element instead\n\t                        curToNodeChild = savedEl;\n\t                    } else {\n\t                        // The current DOM element in the target tree has an ID\n\t                        // but we did not find a match in any of the\n\t                        // corresponding siblings. We just put the target\n\t                        // element in the old DOM tree but if we later find an\n\t                        // element in the old DOM tree that has a matching ID\n\t                        // then we will replace the target element with the\n\t                        // corresponding old element and morph the old element\n\t                        unmatchedEls[curToNodeId] = curToNodeChild;\n\t                    }\n\t                }\n\t\n\t                // If we got this far then we did not find a candidate match for\n\t                // our \"to node\" and we exhausted all of the children \"from\"\n\t                // nodes. Therefore, we will just append the current \"to node\"\n\t                // to the end\n\t                if (onBeforeNodeAdded(curToNodeChild) !== false) {\n\t                    fromEl.appendChild(curToNodeChild);\n\t                    onNodeAdded(curToNodeChild);\n\t                }\n\t\n\t                if (curToNodeChild.nodeType === Node.ELEMENT_NODE &&\n\t                    (curToNodeId || curToNodeChild.firstChild)) {\n\t                    // The element that was just added to the original DOM may\n\t                    // have some nested elements with a key/ID that needs to be\n\t                    // matched up with other elements. We'll add the element to\n\t                    // a list so that we can later process the nested elements\n\t                    // if there are any unmatched keyed elements that were\n\t                    // discarded\n\t                    movedEls.push(curToNodeChild);\n\t                }\n\t\n\t                curToNodeChild = toNextSibling;\n\t                curFromNodeChild = fromNextSibling;\n\t            }\n\t\n\t            // We have processed all of the \"to nodes\". If curFromNodeChild is\n\t            // non-null then we still have some from nodes left over that need\n\t            // to be removed\n\t            while (curFromNodeChild) {\n\t                fromNextSibling = curFromNodeChild.nextSibling;\n\t                removeNode(curFromNodeChild, fromEl, alreadyVisited);\n\t                curFromNodeChild = fromNextSibling;\n\t            }\n\t        }\n\t\n\t        var specialElHandler = specialElHandlers[fromEl.nodeName];\n\t        if (specialElHandler) {\n\t            specialElHandler(fromEl, toEl);\n\t        }\n\t    } // END: morphEl(...)\n\t\n\t    var morphedNode = fromNode;\n\t    var morphedNodeType = morphedNode.nodeType;\n\t    var toNodeType = toNode.nodeType;\n\t\n\t    if (!childrenOnly) {\n\t        // Handle the case where we are given two DOM nodes that are not\n\t        // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n\t        if (morphedNodeType === Node.ELEMENT_NODE) {\n\t            if (toNodeType === Node.ELEMENT_NODE) {\n\t                if (!compareNodeNames(fromNode, toNode)) {\n\t                    onNodeDiscarded(fromNode);\n\t                    morphedNode = moveChildren(fromNode, createElement(toNode.nodeName, toNode.namespaceURI));\n\t                }\n\t            } else {\n\t                // Going from an element node to a text node\n\t                morphedNode = toNode;\n\t            }\n\t        } else if (morphedNodeType === Node.TEXT_NODE) { // Text node\n\t            if (toNodeType === Node.TEXT_NODE) {\n\t                morphedNode.nodeValue = toNode.nodeValue;\n\t                return morphedNode;\n\t            } else {\n\t                // Text node to something else\n\t                morphedNode = toNode;\n\t            }\n\t        }\n\t    }\n\t\n\t    if (morphedNode === toNode) {\n\t        // The \"to node\" was not compatible with the \"from node\" so we had to\n\t        // toss out the \"from node\" and use the \"to node\"\n\t        onNodeDiscarded(fromNode);\n\t    } else {\n\t        morphEl(morphedNode, toNode, false, childrenOnly);\n\t\n\t        /**\n\t         * What we will do here is walk the tree for the DOM element that was\n\t         * moved from the target DOM tree to the original DOM tree and we will\n\t         * look for keyed elements that could be matched to keyed elements that\n\t         * were earlier discarded.  If we find a match then we will move the\n\t         * saved element into the final DOM tree.\n\t         */\n\t        var handleMovedEl = function(el) {\n\t            var curChild = el.firstChild;\n\t            while (curChild) {\n\t                var nextSibling = curChild.nextSibling;\n\t\n\t                var key = getNodeKey(curChild);\n\t                if (key) {\n\t                    var savedEl = savedEls[key];\n\t                    if (savedEl && compareNodeNames(curChild, savedEl)) {\n\t                        curChild.parentNode.replaceChild(savedEl, curChild);\n\t                        // true: already visited the saved el tree\n\t                        morphEl(savedEl, curChild, true);\n\t                        curChild = nextSibling;\n\t                        if (empty(savedEls)) {\n\t                            return false;\n\t                        }\n\t                        continue;\n\t                    }\n\t                }\n\t\n\t                if (curChild.nodeType === Node.ELEMENT_NODE) {\n\t                    handleMovedEl(curChild);\n\t                }\n\t\n\t                curChild = nextSibling;\n\t            }\n\t        };\n\t\n\t        // The loop below is used to possibly match up any discarded\n\t        // elements in the original DOM tree with elemenets from the\n\t        // target tree that were moved over without visiting their\n\t        // children\n\t        if (!empty(savedEls)) {\n\t            handleMovedElsLoop:\n\t            while (movedEls.length) {\n\t                var movedElsTemp = movedEls;\n\t                movedEls = [];\n\t                for (var i=0; i<movedElsTemp.length; i++) {\n\t                    if (handleMovedEl(movedElsTemp[i]) === false) {\n\t                        // There are no more unmatched elements so completely end\n\t                        // the loop\n\t                        break handleMovedElsLoop;\n\t                    }\n\t                }\n\t            }\n\t        }\n\t\n\t        // Fire the \"onNodeDiscarded\" event for any saved elements\n\t        // that never found a new home in the morphed DOM\n\t        for (var savedElId in savedEls) {\n\t            if (savedEls.hasOwnProperty(savedElId)) {\n\t                var savedEl = savedEls[savedElId];\n\t                onNodeDiscarded(savedEl);\n\t                walkDiscardedChildNodes(savedEl);\n\t            }\n\t        }\n\t    }\n\t\n\t    if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n\t        // If we had to swap out the from node with a new node because the old\n\t        // node was not compatible with the target node then we need to\n\t        // replace the old DOM node in the original DOM tree. This is only\n\t        // possible if the original DOM node was part of a DOM tree which\n\t        // we know is the case if it has a parent node.\n\t        fromNode.parentNode.replaceChild(morphedNode, fromNode);\n\t    }\n\t\n\t    return morphedNode;\n\t}\n\t\n\tmodule.exports = morphdom;\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\tvar prefix = 't-';\n\t\n\tvar T = {\n\t  PREFIX: prefix\n\t};\n\t\n\tT.AS = prefix + 'as';\n\tT.EACH = prefix + 'each';\n\tT.ELSE = prefix + 'else';\n\tT.FOREACH = prefix + 'foreach';\n\tT.IF = prefix + 'if';\n\tT.SKIP = prefix + 'skip';\n\tT.TEXT = prefix + 'text';\n\tT.WITH = prefix + 'with';\n\t\n\tmodule.exports.T = T;\n\t\n\tmodule.exports.CONTROL_ATTRS = [\n\t  'as',\n\t  'each',\n\t  'else',\n\t  'foreach',\n\t  'if',\n\t  'skip',\n\t  'text',\n\t  'with'\n\t];\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar constants = __webpack_require__(14);\n\tvar T_PREFIX = constants.T.PREFIX;\n\tvar CONTROL_ATTRS = constants.CONTROL_ATTRS;\n\t\n\tvar ns = __webpack_require__(12);\n\tvar util = __webpack_require__(10);\n\tvar defined = util.defined;\n\t\n\tmodule.exports.getAttributeMap = function(node) {\n\t  var map = {};\n\t  var attrs = node.attributes;\n\t  for (var i = 0; i < attrs.length; i++) {\n\t    var attr = attrs[i];\n\t    var name = ns.qualify(attr.name);\n\t    var localName = name.localName;\n\t    var value = attr.value;\n\t    if (localName.indexOf(T_PREFIX) === 0) {\n\t      localName = localName.substr(T_PREFIX.length);\n\t      if (CONTROL_ATTRS.indexOf(localName) > -1) {\n\t        continue;\n\t      }\n\t      value = util.compileExpression(value);\n\t    }\n\t    var qname = name.prefix\n\t      ? name.prefix + ':' + localName\n\t      : localName;\n\t    map[qname] = value;\n\t  }\n\t  return map;\n\t};\n\t\n\tmodule.exports.interpolateAttributes = function(attrMap, data) {\n\t  var attrs = {};\n\t  for (var key in attrMap) {\n\t    if (!attrMap.hasOwnProperty(key)) {\n\t      continue;\n\t    }\n\t    var value = attrMap[key];\n\t    // only apply functions for attrs that aren't event handlers\n\t    if (typeof value === 'function' && key.indexOf('on') !== 0) {\n\t      value = value.call(this, data, key);\n\t    }\n\t    if (defined(value)) {\n\t      attrs[key] = value;\n\t    }\n\t  }\n\t  return attrs;\n\t};\n\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\tmodule.exports.getPreviousSibling = function(node, selector) {\n\t  // eslint-disable-next-line no-cond-assign\n\t  while (node = node.previousSibling) {\n\t    if (!node) break;\n\t    // FIXME this needs a vendor prefix in IE 9+\n\t    // <http://caniuse.com/#search=matches>\n\t    if (node.nodeType === 1 && node.matches(selector)) {\n\t      return node;\n\t    }\n\t  }\n\t  throw new Error('no previous sibling found matching: ' + selector);\n\t};\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\tvar renderEach = function(fn, render, symbol) {\n\t  return function(data) {\n\t    var values = fn.call(this, data);\n\t    return forEach.call(this, values, render, symbol);\n\t  };\n\t};\n\t\n\tvar renderWith = function(fn, render, symbol) {\n\t  render = symbolSetter(symbol, render);\n\t  return function(data) {\n\t    data = fn.call(this, data);\n\t    return render.call(this, data);\n\t  };\n\t};\n\t\n\tvar forEach = function(data, fn, symbol) {\n\t  var iterate = symbol\n\t    ? symbolSetter(symbol, fn)\n\t    : fn;\n\t\n\t  var result = [];\n\t  var INDEX = '$i';\n\t  var each = function(d, i) {\n\t    this[INDEX] = i;\n\t    result.push(iterate.call(this, d));\n\t    delete this[INDEX];\n\t  };\n\t\n\t  if (typeof data === 'object') {\n\t    if (Array.isArray(data)) {\n\t      data.forEach(each, this);\n\t    } else {\n\t      var i = 0;\n\t      for (var key in data) {\n\t        if (data.hasOwnProperty(key)) {\n\t          each.call(this, {key: key, value: data[key]}, i++);\n\t        }\n\t      }\n\t    }\n\t  } else if (typeof data === 'string') {\n\t    data.split('').forEach(each, this);\n\t  }\n\t\n\t  return result;\n\t};\n\t\n\tvar symbolSetter = function(symbol, fn) {\n\t  return function(data) {\n\t    var previous = set(this, symbol, data);\n\t    var result = fn.call(this, data);\n\t    set(this, symbol, previous);\n\t    return result;\n\t  };\n\t};\n\t\n\tvar set = function(context, symbol, value) {\n\t  var previous = context[symbol];\n\t  if (value === undefined) {\n\t    delete context[symbol];\n\t  } else {\n\t    context[symbol] = value;\n\t  }\n\t  return previous;\n\t};\n\t\n\tmodule.exports = {\n\t  renderWith: renderWith,\n\t  renderEach: renderEach,\n\t  symbolSetter: symbolSetter\n\t};\n\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** tagalong.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 6ba0cbeba1ce3bb270d2\n **/","require('document-register-element');\n\nvar Template = require('./t-template');\nvar render = require('./render');\n\nwindow.tagalong = {\n  Template: Template,\n  createRenderer: render.create,\n  render: render.render\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/main.js\n ** module id = 0\n ** module chunks = 0\n **/","/*! (C) WebReflection Mit Style License */\n(function(e,t,n,r){\"use strict\";function rt(e,t){for(var n=0,r=e.length;n<r;n++)vt(e[n],t)}function it(e){for(var t=0,n=e.length,r;t<n;t++)r=e[t],nt(r,b[ot(r)])}function st(e){return function(t){j(t)&&(vt(t,e),rt(t.querySelectorAll(w),e))}}function ot(e){var t=e.getAttribute(\"is\"),n=e.nodeName.toUpperCase(),r=S.call(y,t?v+t.toUpperCase():d+n);return t&&-1<r&&!ut(n,t)?-1:r}function ut(e,t){return-1<w.indexOf(e+'[is=\"'+t+'\"]')}function at(e){var t=e.currentTarget,n=e.attrChange,r=e.attrName,i=e.target;Q&&(!i||i===t)&&t.attributeChangedCallback&&r!==\"style\"&&e.prevValue!==e.newValue&&t.attributeChangedCallback(r,n===e[a]?null:e.prevValue,n===e[l]?null:e.newValue)}function ft(e){var t=st(e);return function(e){X.push(t,e.target)}}function lt(e){K&&(K=!1,e.currentTarget.removeEventListener(h,lt)),rt((e.target||t).querySelectorAll(w),e.detail===o?o:s),B&&pt()}function ct(e,t){var n=this;q.call(n,e,t),G.call(n,{target:n})}function ht(e,t){D(e,t),et?et.observe(e,z):(J&&(e.setAttribute=ct,e[i]=Z(e),e.addEventListener(p,G)),e.addEventListener(c,at)),e.createdCallback&&Q&&(e.created=!0,e.createdCallback(),e.created=!1)}function pt(){for(var e,t=0,n=F.length;t<n;t++)e=F[t],E.contains(e)||(n--,F.splice(t--,1),vt(e,o))}function dt(e){throw new Error(\"A \"+e+\" type is already registered\")}function vt(e,t){var n,r=ot(e);-1<r&&(tt(e,b[r]),r=0,t===s&&!e[s]?(e[o]=!1,e[s]=!0,r=1,B&&S.call(F,e)<0&&F.push(e)):t===o&&!e[o]&&(e[s]=!1,e[o]=!0,r=1),r&&(n=e[t+\"Callback\"])&&n.call(e))}if(r in t)return;var i=\"__\"+r+(Math.random()*1e5>>0),s=\"attached\",o=\"detached\",u=\"extends\",a=\"ADDITION\",f=\"MODIFICATION\",l=\"REMOVAL\",c=\"DOMAttrModified\",h=\"DOMContentLoaded\",p=\"DOMSubtreeModified\",d=\"<\",v=\"=\",m=/^[A-Z][A-Z0-9]*(?:-[A-Z0-9]+)+$/,g=[\"ANNOTATION-XML\",\"COLOR-PROFILE\",\"FONT-FACE\",\"FONT-FACE-SRC\",\"FONT-FACE-URI\",\"FONT-FACE-FORMAT\",\"FONT-FACE-NAME\",\"MISSING-GLYPH\"],y=[],b=[],w=\"\",E=t.documentElement,S=y.indexOf||function(e){for(var t=this.length;t--&&this[t]!==e;);return t},x=n.prototype,T=x.hasOwnProperty,N=x.isPrototypeOf,C=n.defineProperty,k=n.getOwnPropertyDescriptor,L=n.getOwnPropertyNames,A=n.getPrototypeOf,O=n.setPrototypeOf,M=!!n.__proto__,_=n.create||function mt(e){return e?(mt.prototype=e,new mt):this},D=O||(M?function(e,t){return e.__proto__=t,e}:L&&k?function(){function e(e,t){for(var n,r=L(t),i=0,s=r.length;i<s;i++)n=r[i],T.call(e,n)||C(e,n,k(t,n))}return function(t,n){do e(t,n);while((n=A(n))&&!N.call(n,t));return t}}():function(e,t){for(var n in t)e[n]=t[n];return e}),P=e.MutationObserver||e.WebKitMutationObserver,H=(e.HTMLElement||e.Element||e.Node).prototype,B=!N.call(H,E),j=B?function(e){return e.nodeType===1}:function(e){return N.call(H,e)},F=B&&[],I=H.cloneNode,q=H.setAttribute,R=H.removeAttribute,U=t.createElement,z=P&&{attributes:!0,characterData:!0,attributeOldValue:!0},W=P||function(e){J=!1,E.removeEventListener(c,W)},X,V=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,10)},$=!1,J=!0,K=!0,Q=!0,G,Y,Z,et,tt,nt;O||M?(tt=function(e,t){N.call(t,e)||ht(e,t)},nt=ht):(tt=function(e,t){e[i]||(e[i]=n(!0),ht(e,t))},nt=tt),B?(J=!1,function(){var e=k(H,\"addEventListener\"),t=e.value,n=function(e){var t=new CustomEvent(c,{bubbles:!0});t.attrName=e,t.prevValue=this.getAttribute(e),t.newValue=null,t[l]=t.attrChange=2,R.call(this,e),this.dispatchEvent(t)},r=function(e,t){var n=this.hasAttribute(e),r=n&&this.getAttribute(e),i=new CustomEvent(c,{bubbles:!0});q.call(this,e,t),i.attrName=e,i.prevValue=n?r:null,i.newValue=t,n?i[f]=i.attrChange=1:i[a]=i.attrChange=0,this.dispatchEvent(i)},s=function(e){var t=e.currentTarget,n=t[i],r=e.propertyName,s;n.hasOwnProperty(r)&&(n=n[r],s=new CustomEvent(c,{bubbles:!0}),s.attrName=n.name,s.prevValue=n.value||null,s.newValue=n.value=t[r]||null,s.prevValue==null?s[a]=s.attrChange=0:s[f]=s.attrChange=1,t.dispatchEvent(s))};e.value=function(e,o,u){e===c&&this.attributeChangedCallback&&this.setAttribute!==r&&(this[i]={className:{name:\"class\",value:this.className}},this.setAttribute=r,this.removeAttribute=n,t.call(this,\"propertychange\",s)),t.call(this,e,o,u)},C(H,\"addEventListener\",e)}()):P||(E.addEventListener(c,W),E.setAttribute(i,1),E.removeAttribute(i),J&&(G=function(e){var t=this,n,r,s;if(t===e.target){n=t[i],t[i]=r=Z(t);for(s in r){if(!(s in n))return Y(0,t,s,n[s],r[s],a);if(r[s]!==n[s])return Y(1,t,s,n[s],r[s],f)}for(s in n)if(!(s in r))return Y(2,t,s,n[s],r[s],l)}},Y=function(e,t,n,r,i,s){var o={attrChange:e,currentTarget:t,attrName:n,prevValue:r,newValue:i};o[s]=e,at(o)},Z=function(e){for(var t,n,r={},i=e.attributes,s=0,o=i.length;s<o;s++)t=i[s],n=t.name,n!==\"setAttribute\"&&(r[n]=t.value);return r})),t[r]=function(n,r){c=n.toUpperCase(),$||($=!0,P?(et=function(e,t){function n(e,t){for(var n=0,r=e.length;n<r;t(e[n++]));}return new P(function(r){for(var i,s,o,u=0,a=r.length;u<a;u++)i=r[u],i.type===\"childList\"?(n(i.addedNodes,e),n(i.removedNodes,t)):(s=i.target,Q&&s.attributeChangedCallback&&i.attributeName!==\"style\"&&(o=s.getAttribute(i.attributeName),o!==i.oldValue&&s.attributeChangedCallback(i.attributeName,i.oldValue,o)))})}(st(s),st(o)),et.observe(t,{childList:!0,subtree:!0})):(X=[],V(function E(){while(X.length)X.shift().call(null,X.shift());V(E)}),t.addEventListener(\"DOMNodeInserted\",ft(s)),t.addEventListener(\"DOMNodeRemoved\",ft(o))),t.addEventListener(h,lt),t.addEventListener(\"readystatechange\",lt),t.createElement=function(e,n){var r=U.apply(t,arguments),i=\"\"+e,s=S.call(y,(n?v:d)+(n||i).toUpperCase()),o=-1<s;return n&&(r.setAttribute(\"is\",n=n.toLowerCase()),o&&(o=ut(i.toUpperCase(),n))),Q=!t.createElement.innerHTMLHelper,o&&nt(r,b[s]),r},H.cloneNode=function(e){var t=I.call(this,!!e),n=ot(t);return-1<n&&nt(t,b[n]),e&&it(t.querySelectorAll(w)),t}),-2<S.call(y,v+c)+S.call(y,d+c)&&dt(n);if(!m.test(c)||-1<S.call(g,c))throw new Error(\"The type \"+n+\" is invalid\");var i=function(){return f?t.createElement(l,c):t.createElement(l)},a=r||x,f=T.call(a,u),l=f?r[u].toUpperCase():c,c,p;return f&&-1<S.call(y,d+l)&&dt(l),p=y.push((f?v:d)+c)-1,w=w.concat(w.length?\",\":\"\",f?l+'[is=\"'+n.toLowerCase()+'\"]':l),i.prototype=b[p]=T.call(a,\"prototype\")?a.prototype:_(H),rt(t.querySelectorAll(w),s),i}})(window,document,Object,\"registerElement\");\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/document-register-element/build/document-register-element.js\n ** module id = 1\n ** module chunks = 0\n **/","var property = require('./property');\nvar evaluate = require('./evaluate').evaluate;\nvar createRenderer = require('./render').create;\n\nvar RENDER = '[[t-render]]';\n\nvar DATA_ATTR = 'data';\n\nvar Template = document.registerElement('t-template', {\n  prototype: Object.create(\n    HTMLElement.prototype,\n    {\n      attachedCallback: {value: function() {\n        this.update();\n      }},\n\n      // eslint-disable-next-line no-unused-vars\n      attributeChangedCallback: {value: function(attr, value, previous) {\n        switch (attr) {\n          case DATA_ATTR:\n            this.update();\n            break;\n          default:\n            return;\n        }\n      }},\n\n      update: {value: function() {\n        console.log('updating...');\n        if (this.hasAttribute(DATA_ATTR)) {\n          var expr = this.getAttribute(DATA_ATTR);\n          var data = evaluate(expr);\n          console.log('setting data: (', expr, ') ->', data);\n          this.data = data;\n        }\n      }},\n\n      /**\n       * @param {Object?} data\n       */\n      render: {value: function(data) {\n        if (!arguments.length) {\n          data = this.data;\n        }\n\n        var render = this[RENDER];\n        if (!render) {\n          render = this[RENDER] = createRenderer(this);\n        }\n\n        render(data);\n        return data;\n      }},\n\n      /**\n       * @param {Element} node\n       * @param {Object?} data\n       */\n      renderTo: {value: function(node, data) {\n        if (arguments.length < 2) {\n          data = this.data;\n        }\n\n        var render = this[RENDER];\n        if (!render) {\n          render = this[RENDER] = createRenderer(this);\n        }\n        render(node, data);\n        return data;\n      }},\n\n      /**\n       * Invalidate this element's compiled template, so that it\n       * will be recompiled on the next render.\n       */\n      invalidate: {value: function() {\n        this[RENDER] = null;\n      }},\n\n      /**\n       * Returns the element's bound data.\n       */\n      data: property(\n        function readTemplateData(data) {\n          return data;\n        },\n        // eslint-disable-next-line no-unused-vars\n        function setTemplateData(data, previous) {\n          return this.render(data);\n        },\n        {}\n      )\n    }\n  )\n});\n\n// only listen for changes to the data attribute\nObject.defineProperty(Template, 'observedAttributes', {\n  get: function() {\n    return [DATA_ATTR];\n  }\n});\n\nmodule.exports = Template;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/t-template.js\n ** module id = 2\n ** module chunks = 0\n **/","module.exports = function property(read, write, defaultValue) {\n  var symbol = '[[t-' + Date.now() + ']]';\n  return {\n    enumerable: false,\n\n    get: function() {\n      var value = (symbol in this)\n        ? this[symbol]\n        : this[symbol] = defaultValue;\n      return read\n        ? read.call(this, value)\n        : value;\n    },\n\n    set: function(value) {\n      var previous = this[symbol];\n      if (value !== previous) {\n        // eslint-disable-next-line no-return-assign\n        return this[symbol] = write.call(this, value, previous);\n      }\n      return undefined;\n    }\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/property.js\n ** module id = 3\n ** module chunks = 0\n **/","/* eslint no-new-func: \"warn\" */\nvar arrow = require('./arrow');\nvar functor = require('./functor');\n\nvar evaluate = function(expression, data) {\n  var fn = evaluator(expression);\n  return fn.call(this, data);\n};\n\nvar evaluator = function(expression) {\n  if (typeof expression !== 'string') {\n    expression = String(expression);\n  }\n\n  if (!expression.trim()) {\n    return functor(undefined);\n  }\n\n  if (arrow.is(expression)) {\n    return arrow.parse(expression);\n  }\n\n  var symbol = 'd';\n  // '.' is just the identity function\n  if (expression.match(/^\\s*\\.\\s*$/)) {\n    return identity;\n  // '.foo' addresses the context directly\n  } else if (expression.match(/^\\s*\\.\\w/)) {\n    expression = symbol + expression;\n  }\n  return new Function(symbol, [\n    // 'console.info(\"', symbol, ' = \", ', symbol, ', \"', expression, '\"); ',\n    'try { ',\n    '  with (this) {',\n    '    with (', symbol, ') {',\n    '      return (', expression, ');',\n    '    } ',\n    '  } ',\n    '} catch (error) { }'\n  ].join('\\n'));\n};\n\nmodule.exports = {\n  evaluate: evaluate,\n  evaluator: evaluator\n};\n\nfunction identity(d) {\n  return d;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/evaluate.js\n ** module id = 4\n ** module chunks = 0\n **/","/* eslint no-new-func: \"warn\" */\nvar ARROW_PATTERN = /^\\s*\\(?(\\s*\\w+\\s*(,\\s*\\w+\\s*)*)?\\)?\\s*=>\\s*({([^}]+)}|(.+))$/;\n\nvar isArrow = function(expression) {\n  return String(expression).match(ARROW_PATTERN);\n};\n\nvar parseArrow = function parseArrow(expression) {\n  var match = expression.match(ARROW_PATTERN);\n  if (!match) throw new Error('invalid arrow expression: \"' + expression + '\"');\n  var args = match[1];\n  var body = (match[4] || match[5]).trim() || 'undefined';\n  return new Function(args, [\n    'with (this) {',\n    ' return ', body, '; ',\n    '}',\n  ].join(''));\n};\n\nmodule.exports = {\n  is: isArrow,\n  parse: parseArrow\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/arrow.js\n ** module id = 5\n ** module chunks = 0\n **/","module.exports = function functor(x) {\n  return function f() {\n    return x;\n  };\n};\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/functor.js\n ** module id = 6\n ** module chunks = 0\n **/","var code = require('./evaluate');\nvar interpolate = require('./interpolate');\nvar compose = require('./compose');\nvar h = require('./h');\n\nvar morphdom = require('morphdom');\n\nvar T = require('./constants').T;\nvar T_ID = 't-id';\nvar attr = require('./attrs');\nvar dom = require('./dom');\nvar util = require('./util');\nvar ns = require('./ns');\nvar scope = require('./scope');\n\n// this is our symbol on which we stash registered event handlers, so that\n// we can remove any registered handlers before adding new ones.\nvar EVENTS = '[[t-events]]';\n\n// we stash unique event handler ids and handlers by id, each bound to the\n// renered template data\nvar eventHandlerId = 0;\nvar eventHandlersById = {};\n\n/**\n * Returns a function that generates an interpolated string for the\n * given text node (`node.nodeType === Node.TEXT_NODE`).\n *\n * @param {Node} node\n * @return {Function} function(data:Object):String\n */\nvar createTextRenderer = function(node) {\n  return compose.stringify(interpolate.compile(node.nodeValue));\n};\n\nvar createCommentRenderer = function(node) {\n  var value = compose.stringify(interpolate.compile(node.nodeValue));\n  return function() {\n    return document.createComment(value.apply(this, arguments));\n  };\n};\n\n/**\n * \"Pluck\" event handlers from an attribute map, removing them from\n * the map. If no event handlers are found, the return value is\n * `undefined`.\n *\n * @param {Object} attrMap\n * @return {Object}\n */\nvar pluckEventHandlers = function(attrMap) {\n  var handlers = undefined;\n  for (var name in attrMap) {\n    var value = attrMap[name];\n    if (name.indexOf('on') === 0 && typeof value === 'function') {\n      if (!handlers) {\n        handlers = {};\n      }\n      handlers[name.substr(2)] = value;\n      delete attrMap[name];\n    }\n  }\n  return handlers;\n};\n\n/**\n * This function returns a node rendering wrapper that registers event handlers\n * for the rendered node by assigning it a unique `t-id` attribute and stashing\n * a reference to the data-bound handlers in a corresponding hash. After the\n * tree is morphed, each element with a `t-id` attribute is then matched up\n * with its event handlers.\n *\n * @param {Function} render\n * @param {Object} handlers each key is an event type, and the value is a\n * callback function.\n * @return {Function} a function that returns the rendered node\n */\nvar registerEventHandlers = function(render, handlers) {\n  return function(data, index) {\n    var node = render.apply(this, arguments);\n    if (node) {\n      var tid = ++eventHandlerId;\n      node.setAttribute(T_ID, tid);\n      var context = this;\n      var callback = function(event) {\n        // XXX in theory, this could fail if one\n        // of the handlers gets removed (not\n        // sure how that would happen, though)\n        handlers[event.type].call(context, data, event);\n      };\n      var bound = {};\n      for (var type in handlers) {\n        bound[type] = callback;\n      }\n      eventHandlersById[tid] = bound;\n    }\n    return node;\n  };\n};\n\n/**\n * Returns a function that generates an interpolated DOM element tree\n * for the given element node\n * (`node.nodeType === Node.ELEMENT_NODE`).\n *\n * @param {Element} node\n * @return {Function} function(data:Object):Element\n */\nvar createElementRenderer = function(node) {\n  // this element will never be rendered if it has a truthy t-skip\n  // attribute\n  if (node.hasAttribute(T.SKIP)) {\n    return undefined;\n  }\n\n  var name = ns.getPrefixedName(node);\n  var attrMap = attr.getAttributeMap(node);\n  var handlers = pluckEventHandlers(attrMap);\n\n  var condition = node.hasAttribute(T.IF)\n    ? code.evaluator(node.getAttribute(T.IF))\n    : undefined;\n\n  if (node.hasAttribute(T.ELSE)) {\n    if (condition) {\n      throw new Error('element has both t-if and t-else attributes');\n    }\n    // TODO: ELSEIF should just collect all of the previous IF and\n    // ELSEIF nodes and negate them. Some checking should happen here to\n    // ensure that they're specified in the correct order.\n    var ifSibling = dom.getPreviousSibling(node, '[' + T.IF + ']');\n    if (!ifSibling) {\n      throw new Error('element with t-else has no matching t-if sibling');\n    }\n    condition = compose.not(code.evaluator(ifSibling.getAttribute(T.IF)));\n  }\n\n  var renderChildren;\n\n  // <span t-text=\"some.value\"></span>\n  if (node.hasAttribute(T.TEXT)) {\n    renderChildren = compose.stringify(\n      util.compileExpression(node.getAttribute(T.TEXT))\n    );\n  } else {\n    var childRenderers = [].map.call(node.childNodes, compile);\n    renderChildren = function(data) {\n      return childRenderers.map(function(renderChild, i) {\n        return (typeof renderChild === 'function')\n          ? renderChild.call(this, data)\n          : renderChild;\n      }, this);\n    };\n  }\n\n  var renderNode = function(data) {\n    if (condition && !condition.call(this, data)) {\n      return undefined;\n    }\n\n    var attrs = attr.interpolateAttributes.call(this, attrMap, data);\n    var children = renderChildren.call(this, data);\n    return h(name, attrs, children);\n  };\n\n  // \"attach\" (as a single property) the event handler maps\n  if (handlers) {\n    renderNode = registerEventHandlers(renderNode, handlers);\n  }\n\n  var eachExpression = node.getAttribute(T.EACH);\n  var forEachExpression = node.getAttribute(T.FOREACH);\n  var withExpression = node.getAttribute(T.WITH);\n\n  var symbol = node.getAttribute(T.AS);\n\n  if (eachExpression) {\n    renderNode = scope.renderEach(\n      code.evaluator(eachExpression),\n      renderNode,\n      symbol\n    );\n  } else if (forEachExpression) {\n    renderChildren = scope.renderEach(\n      code.evaluator(forEachExpression),\n      renderChildren,\n      symbol\n    );\n  } else if (withExpression) {\n    renderNode = scope.renderWith(\n      code.evaluator(withExpression),\n      renderNode,\n      symbol\n    );\n  } else if (symbol) {\n    renderNode = scope.symbolSetter(symbol, renderNode);\n  }\n\n  return renderNode;\n};\n\n/**\n * Returns a rendering function for a given source (\"template\") node\n * and optional variable context for expressions.\n *\n * The returned function has the signatures:\n *\n * function(data:*)\n * function(node:Node, data:*)\n *\n * Where `data` is expected to be an object and, in the second form,\n * `node` is a target node to which the diffed DOM should be applied.\n *\n * @param {Node}    src\n * @param {Object?} context\n * @return {Function}\n */\nvar createRenderer = function(src, context) {\n  if (typeof src === 'string') {\n    var selector = src;\n    src = document.querySelector(src);\n    if (!src) {\n      throw new Error('no element found with selector: \"' + selector + '\"');\n    }\n  }\n\n  var renderNode = compile(src);\n  return function(node, data, options) {\n    if (arguments.length < 2) {\n      data = node;\n    }\n    if ((!node && data) || node === data) {\n      node = src;\n    }\n    eventHandlerId = 0;\n    eventHandlersById = {};\n    var dest = renderNode.call(context, data);\n    var result = morphdom(src, dest, options);\n    updateEventHandlers(result);\n    return result;\n  };\n};\n\n/**\n * Update all of the event handlers in the given DOM tree. This looks for all\n * elements with the `t-id` attribute (including the root), removes any\n * existing handlers (stashed in the `[[t-events]]` symbol), then looks up the\n * registered handlers for the corresponding `t-id` value and adds those.\n *\n * @param {Element} root\n */\nvar updateEventHandlers = function(root) {\n  var elements = [].slice.call(root.querySelectorAll('[' + T_ID + ']'));\n  if (root.hasAttribute(T_ID)) {\n    elements.unshift(root);\n  }\n  elements.forEach(function(el) {\n    var events = el[EVENTS];\n    var type;\n    if (events) {\n      for (type in events) {\n        el.removeEventListener(type, events[type], true);\n        delete events[type];\n      }\n      delete el[EVENTS];\n    }\n    var tid = el.getAttribute(T_ID);\n    events = eventHandlersById[tid];\n    if (events) {\n      for (type in events) {\n        el.addEventListener(type, events[type], true);\n      }\n      el[EVENTS] = events;\n    }\n    el.removeAttribute(T_ID);\n  });\n};\n\n/**\n * Creates a renderer, renders once if data is provided, and returns\n * a bound rendering function for subsequent calling.\n *\n * @param {Node}    src\n * @param {Object?} context\n * @return {Function}\n */\nvar render = function(src, data, context) {\n  var renderData = createRenderer(src, context);\n  if (data) {\n    renderData(src, data);\n  }\n  return renderData;\n};\n\n/**\n * Returns a DOM element rendering function for the given \"template\"\n * or source node. This may be publicly exposed if it becomes useful,\n * e.g. for composition of referenced templates.\n *\n * @param {Node} node\n * @return {Function} the returned function takes data and returns an\n * unattached Node instance: function(data:Object):Node\n */\nvar compile = function(node) {\n  switch (node.nodeType) {\n    case 1: // Node.ELEMENT_NODE\n      return createElementRenderer(node);\n\n    case 3: // Node.TEXT_NODE\n      return createTextRenderer(node);\n\n    case 8: // Node.COMMENT_NODE\n      return createCommentRenderer(node);\n\n    // TODO: support document fragments?\n    // this would need support in h()\n\n    default:\n      throw new Error('no renderer for node type: ' + node.nodeType);\n  }\n};\n\n\nmodule.exports.render = render;\nmodule.exports.createRenderer = createRenderer;\nmodule.exports.compile = compile;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/render.js\n ** module id = 7\n ** module chunks = 0\n **/","var evaluate = require('./evaluate').evaluate;\nvar functor = require('./functor');\n\nvar pattern = /{{\\s*([^}]+)\\s*}}/g;\n\nvar isTemplate = function(str) {\n  return new RegExp(pattern).test(str);\n};\n\nvar compile = function(template) {\n  if (typeof template !== 'string') {\n    throw new Error('interpolate.compile() expected a string;' +\n                    'got ' + (typeof template));\n  }\n\n  if (!isTemplate(template)) {\n    return functor(template);\n  }\n\n  return function(data) {\n    var that = this;\n    return template.replace(pattern, function(_, part) {\n      return evaluate.call(that, part, data);\n    });\n  };\n};\n\nvar interpolate = function interpolate(str, data) {\n  return compile(str).call(this, data);\n};\n\nmodule.exports = interpolate;\n\nmodule.exports.isTemplate = isTemplate;\n\nmodule.exports.compile = compile;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/interpolate.js\n ** module id = 8\n ** module chunks = 0\n **/","/**\n * functional composition functions take a function and return a\n * wrapped function that calls the passed one and applies some\n * additional logic.\n */\n\nvar defined = require('./util').defined;\n\n/**\n * @param {Function}  fn\n * @return {Function} a function that returns the inverse (`!`)\n *                    value of the `fn`, given the same arguments.\n */\nmodule.exports.not = function(fn) {\n  return function() {\n    return !fn.apply(this, arguments);\n  };\n};\n\n/**\n * @param {Function}  fn\n * @return {Function} a function that returns the stringified\n *                    value of the `fn`, given the same arguments.\n */\nmodule.exports.stringify = function(fn) {\n  return function() {\n    var value = fn.apply(this, arguments);\n    return defined(value) ? String(value) : '';\n  };\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/compose.js\n ** module id = 9\n ** module chunks = 0\n **/","var code = require('./evaluate');\nvar interpolate = require('./interpolate');\n\nmodule.exports.defined = function(value) {\n  return value !== null && value !== undefined;\n};\n\nmodule.exports.compileExpression = function(expr) {\n  return interpolate.isTemplate(expr)\n    ? interpolate.compile(expr)\n    : code.evaluator(expr);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/util.js\n ** module id = 10\n ** module chunks = 0\n **/","var ns = require('./ns');\n\nmodule.exports = function(name, props, children) {\n  var node;\n  if (Array.isArray(name)) {\n    node = document.createDocumentFragment();\n  } else {\n    name = ns.qualify(name);\n    node = name.namespaceURI\n      ? document.createElementNS(name.namespaceURI, name.localName)\n      : document.createElement(name.localName);\n  }\n\n  if (Array.isArray(props) || typeof props === 'string') {\n    children = props;\n  } else if (typeof props === 'object') {\n    setProps(node, props);\n  }\n\n  var append = function(child) {\n    if (Array.isArray(child)) {\n      child.forEach(append);\n    } else if (typeof child === 'object') {\n      node.appendChild(child);\n    } else if (typeof child === 'string') {\n      node.appendChild(document.createTextNode(child));\n    }\n  };\n\n  if (typeof children === 'object' || typeof children === 'string') {\n    append(children);\n  }\n\n  return node;\n};\n\nvar setProps = function(el, props) {\n  for (var prop in props) {\n    if (!props.hasOwnProperty(prop)) {\n      continue;\n    }\n    var value = props[prop];\n    if (value === null || value === undefined || typeof value === 'function') {\n      // XXX: don't add null, undefined, or function values\n      continue;\n    } else if (typeof value === 'object') {\n      switch (prop) {\n        case 'class':\n          value = formatClassName(value);\n          break;\n\n        case 'style':\n          value = formatStyle(value);\n          break;\n\n        default:\n          console.warn('unrecognized object prop:', prop, value);\n          continue;\n      }\n    }\n\n    var name = ns.qualify(prop);\n    if (name.namespaceURI) {\n      el.setAttributeNS(name.namespaceURI, name.name, value);\n    } else {\n      el.setAttribute(name.localName, value);\n    }\n  }\n};\n\nvar formatStyle = function(obj) {\n  if (Array.isArray(obj)) {\n    return obj.join('; ');\n  }\n  return Object.keys(obj)\n    .map(function(key) {\n      return [\n        reformatCamelCase(key),\n        ': ',\n        obj[key],\n        ';'\n      ].join('');\n    })\n    .join(' ');\n};\n\nvar reformatCamelCase = function(str) {\n  return str.replace(/[A-Z]/g, function(char) {\n    return '-' + char.toLowerCase();\n  });\n};\n\nvar formatClassName = function(obj) {\n  if (Array.isArray(obj)) {\n    return obj.join(' ');\n  }\n  return Object.keys(obj).filter(function(key) {\n    return !!obj[key];\n  }).join(' ');\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/h.js\n ** module id = 11\n ** module chunks = 0\n **/","var prefixToURI = {\n  svg: 'http://www.w3.org/2000/svg',\n  xlink: 'http://www.w3.org/TR/xlink/',\n  xmlns: 'http://www.w3.org/2000/xmlns/'\n};\n\nvar uriToPrefix = {};\nObject.keys(prefixToURI).forEach(function(prefix) {\n  uriToPrefix[prefixToURI[prefix]] = prefix;\n});\n\nvar qualify = function(qname) {\n  var prefix;\n  var localName = qname;\n  var colon = qname.indexOf(':');\n  if (colon > -1) {\n    prefix = qname.substr(0, colon);\n    localName = qname.substr(colon + 1);\n  }\n  return {\n    name: qname,\n    localName: localName,\n    prefix: prefix,\n    namespaceURI: prefixToURI[prefix]\n  };\n};\n\nvar getPrefixedName = function(node) {\n  var name = node.nodeName.toLowerCase();\n  var prefix = node.prefix;\n  if (!prefix && node.namespaceURI) {\n    prefix = uriToPrefix[node.namespaceURI];\n  }\n  return prefix\n    ? (prefix + ':' + name)\n    : name;\n};\n\nmodule.exports = {\n  getPrefixedName: getPrefixedName,\n  prefixToURI: prefixToURI,\n  uriToPrefix: uriToPrefix,\n  qualify: qualify\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/ns.js\n ** module id = 12\n ** module chunks = 0\n **/","// Create a range object for efficently rendering strings to elements.\nvar range;\n\nvar testEl = (typeof document !== 'undefined') ?\n    document.body || document.createElement('div') :\n    {};\n\nvar XHTML = 'http://www.w3.org/1999/xhtml';\n\n// Fixes <https://github.com/patrick-steele-idem/morphdom/issues/32>\n// (IE7+ support) <=IE7 does not support el.hasAttribute(name)\nvar hasAttribute;\nif (testEl.hasAttribute) {\n    hasAttribute = function hasAttribute(el, name) {\n        return el.hasAttribute(name);\n    };\n} else {\n    hasAttribute = function hasAttribute(el, name) {\n        return !!el.getAttributeNode(name);\n    };\n}\n\nfunction empty(o) {\n    for (var k in o) {\n        if (o.hasOwnProperty(k)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction toElement(str) {\n    if (!range && document.createRange) {\n        range = document.createRange();\n        range.selectNode(document.body);\n    }\n\n    var fragment;\n    if (range && range.createContextualFragment) {\n        fragment = range.createContextualFragment(str);\n    } else {\n        fragment = document.createElement('body');\n        fragment.innerHTML = str;\n    }\n    return fragment.childNodes[0];\n}\n\nvar specialElHandlers = {\n    /**\n     * Needed for IE. Apparently IE doesn't think that \"selected\" is an\n     * attribute when reading over the attributes using selectEl.attributes\n     */\n    OPTION: function(fromEl, toEl) {\n        fromEl.selected = toEl.selected;\n        if (fromEl.selected) {\n            fromEl.setAttribute('selected', '');\n        } else {\n            fromEl.removeAttribute('selected', '');\n        }\n    },\n    /**\n     * The \"value\" attribute is special for the <input> element since it sets\n     * the initial value. Changing the \"value\" attribute without changing the\n     * \"value\" property will have no effect since it is only used to the set the\n     * initial value.  Similar for the \"checked\" attribute, and \"disabled\".\n     */\n    INPUT: function(fromEl, toEl) {\n        fromEl.checked = toEl.checked;\n        if (fromEl.checked) {\n            fromEl.setAttribute('checked', '');\n        } else {\n            fromEl.removeAttribute('checked');\n        }\n\n        if (fromEl.value !== toEl.value) {\n            fromEl.value = toEl.value;\n        }\n\n        if (!hasAttribute(toEl, 'value')) {\n            fromEl.removeAttribute('value');\n        }\n\n        fromEl.disabled = toEl.disabled;\n        if (fromEl.disabled) {\n            fromEl.setAttribute('disabled', '');\n        } else {\n            fromEl.removeAttribute('disabled');\n        }\n    },\n\n    TEXTAREA: function(fromEl, toEl) {\n        var newValue = toEl.value;\n        if (fromEl.value !== newValue) {\n            fromEl.value = newValue;\n        }\n\n        if (fromEl.firstChild) {\n            fromEl.firstChild.nodeValue = newValue;\n        }\n    }\n};\n\nfunction noop() {}\n\n/**\n * Returns true if two node's names and namespace URIs are the same.\n *\n * @param {Element} a\n * @param {Element} b\n * @return {boolean}\n */\nvar compareNodeNames = function(a, b) {\n    return a.nodeName === b.nodeName &&\n           a.namespaceURI === b.namespaceURI;\n};\n\n/**\n * Create an element, optionally with a known namespace URI.\n *\n * @param {string} name the element name, e.g. 'div' or 'svg'\n * @param {string} [namespaceURI] the element's namespace URI, i.e. the value of\n * its `xmlns` attribute or its inferred namespace.\n *\n * @return {Element}\n */\nfunction createElement(name, namespaceURI) {\n    return (namespaceURI && namespaceURI !== XHTML) ?\n        document.createElementNS(namespaceURI, name) :\n        document.createElement(name);\n}\n\n/**\n * Loop over all of the attributes on the target node and make sure the original\n * DOM node has the same attributes. If an attribute found on the original node\n * is not on the new node then remove it from the original node.\n *\n * @param  {Element} fromNode\n * @param  {Element} toNode\n */\nfunction morphAttrs(fromNode, toNode) {\n    var attrs = toNode.attributes;\n    var i;\n    var attr;\n    var attrName;\n    var attrValue;\n    var foundAttrs = {};\n    var fromValue;\n\n    for (i = attrs.length - 1; i >= 0; i--) {\n        attr = attrs[i];\n        attrName = attr.name;\n        attrValue = attr.value;\n        fromValue = fromNode.getAttributeNS(attr.namespaceURI, attr.name);\n        foundAttrs[attrName] = true;\n\n        if (fromValue !== attrValue) {\n            fromNode.setAttributeNS(\n              attr.namespaceURI,\n              attr.name,\n              attrValue\n            );\n        }\n    }\n\n    // Remove any extra attributes found on the original DOM element that\n    // weren't found on the target element.\n    attrs = fromNode.attributes;\n\n    for (i = attrs.length - 1; i >= 0; i--) {\n        attr = attrs[i];\n        if (attr.specified !== false) {\n            attrName = attr.name;\n            if (!foundAttrs.hasOwnProperty(attrName)) {\n                fromNode.removeAttributeNode(attr);\n            }\n        }\n    }\n}\n\n/**\n * Copies the children of one DOM element to another DOM element\n */\nfunction moveChildren(fromEl, toEl) {\n    var curChild = fromEl.firstChild;\n    while (curChild) {\n        var nextChild = curChild.nextSibling;\n        toEl.appendChild(curChild);\n        curChild = nextChild;\n    }\n    return toEl;\n}\n\nfunction defaultGetNodeKey(node) {\n    return node.id;\n}\n\nfunction morphdom(fromNode, toNode, options) {\n    if (!options) {\n        options = {};\n    }\n\n    if (typeof toNode === 'string') {\n        if (fromNode.nodeName === '#document' || fromNode.nodeName === 'HTML') {\n            var toNodeHtml = toNode;\n            toNode = document.createElement('html');\n            toNode.innerHTML = toNodeHtml;\n        } else {\n            toNode = toElement(toNode);\n        }\n    }\n\n    // XXX optimization: if the nodes are equal, don't morph them\n    /*\n    if (fromNode.isEqualNode(toNode)) {\n      return fromNode;\n    }\n    */\n\n    var savedEls = {}; // Used to save off DOM elements with IDs\n    var unmatchedEls = {};\n    var getNodeKey = options.getNodeKey || defaultGetNodeKey;\n    var onBeforeNodeAdded = options.onBeforeNodeAdded || noop;\n    var onNodeAdded = options.onNodeAdded || noop;\n    var onBeforeElUpdated = options.onBeforeElUpdated || options.onBeforeMorphEl || noop;\n    var onElUpdated = options.onElUpdated || noop;\n    var onBeforeNodeDiscarded = options.onBeforeNodeDiscarded || noop;\n    var onNodeDiscarded = options.onNodeDiscarded || noop;\n    var onBeforeElChildrenUpdated = options.onBeforeElChildrenUpdated || options.onBeforeMorphElChildren || noop;\n    var childrenOnly = options.childrenOnly === true;\n    var movedEls = [];\n\n    function removeNodeHelper(node, nestedInSavedEl) {\n        var id = getNodeKey(node);\n        // If the node has an ID then save it off since we will want\n        // to reuse it in case the target DOM tree has a DOM element\n        // with the same ID\n        if (id) {\n            savedEls[id] = node;\n        } else if (!nestedInSavedEl) {\n            // If we are not nested in a saved element then we know that this node has been\n            // completely discarded and will not exist in the final DOM.\n            onNodeDiscarded(node);\n        }\n\n        if (node.nodeType === Node.ELEMENT_NODE) {\n            var curChild = node.firstChild;\n            while (curChild) {\n                removeNodeHelper(curChild, nestedInSavedEl || id);\n                curChild = curChild.nextSibling;\n            }\n        }\n    }\n\n    function walkDiscardedChildNodes(node) {\n        if (node.nodeType === Node.ELEMENT_NODE) {\n            var curChild = node.firstChild;\n            while (curChild) {\n\n\n                if (!getNodeKey(curChild)) {\n                    // We only want to handle nodes that don't have an ID to avoid double\n                    // walking the same saved element.\n\n                    onNodeDiscarded(curChild);\n\n                    // Walk recursively\n                    walkDiscardedChildNodes(curChild);\n                }\n\n                curChild = curChild.nextSibling;\n            }\n        }\n    }\n\n    function removeNode(node, parentNode, alreadyVisited) {\n        if (onBeforeNodeDiscarded(node) === false) {\n            return;\n        }\n\n        parentNode.removeChild(node);\n        if (alreadyVisited) {\n            if (!getNodeKey(node)) {\n                onNodeDiscarded(node);\n                walkDiscardedChildNodes(node);\n            }\n        } else {\n            removeNodeHelper(node);\n        }\n    }\n\n    function morphEl(fromEl, toEl, alreadyVisited, childrenOnly) {\n        var toElKey = getNodeKey(toEl);\n        if (toElKey) {\n            // If an element with an ID is being morphed then it is will be in the final\n            // DOM so clear it out of the saved elements collection\n            delete savedEls[toElKey];\n        }\n\n        if (!childrenOnly) {\n            if (onBeforeElUpdated(fromEl, toEl) === false) {\n                return;\n            }\n\n            morphAttrs(fromEl, toEl);\n            onElUpdated(fromEl);\n\n            if (onBeforeElChildrenUpdated(fromEl, toEl) === false) {\n                return;\n            }\n        }\n\n        if (fromEl.nodeName !== 'TEXTAREA') {\n            var curToNodeChild = toEl.firstChild;\n            var curFromNodeChild = fromEl.firstChild;\n            var curToNodeId;\n\n            var fromNextSibling;\n            var toNextSibling;\n            var savedEl;\n            var unmatchedEl;\n\n            outer: while (curToNodeChild) {\n                toNextSibling = curToNodeChild.nextSibling;\n                curToNodeId = getNodeKey(curToNodeChild);\n\n                while (curFromNodeChild) {\n                    var curFromNodeId = getNodeKey(curFromNodeChild);\n                    fromNextSibling = curFromNodeChild.nextSibling;\n\n                    if (!alreadyVisited) {\n                        if (curFromNodeId && (unmatchedEl = unmatchedEls[curFromNodeId])) {\n                            unmatchedEl.parentNode.replaceChild(curFromNodeChild, unmatchedEl);\n                            morphEl(curFromNodeChild, unmatchedEl, alreadyVisited);\n                            curFromNodeChild = fromNextSibling;\n                            continue;\n                        }\n                    }\n\n                    var curFromNodeType = curFromNodeChild.nodeType;\n\n                    if (curFromNodeType === curToNodeChild.nodeType) {\n                        var isCompatible = false;\n\n                        // Both nodes being compared are Element nodes\n                        if (curFromNodeType === Node.ELEMENT_NODE) {\n                            if (compareNodeNames(curFromNodeChild, curToNodeChild)) {\n                                // We have compatible DOM elements\n                                if (curFromNodeId || curToNodeId) {\n                                    // If either DOM element has an ID then we\n                                    // handle those differently since we want to\n                                    // match up by ID\n                                    if (curToNodeId === curFromNodeId) {\n                                        isCompatible = true;\n                                    }\n                                } else {\n                                    isCompatible = true;\n                                }\n                            }\n\n                            if (isCompatible) {\n                                // We found compatible DOM elements so transform\n                                // the current \"from\" node to match the current\n                                // target DOM node.\n                                morphEl(curFromNodeChild, curToNodeChild, alreadyVisited);\n                            }\n                        // Both nodes being compared are Text nodes\n                        } else if (curFromNodeType === Node.TEXT_NODE) {\n                            isCompatible = true;\n                            // Simply update nodeValue on the original node to\n                            // change the text value\n                            curFromNodeChild.nodeValue = curToNodeChild.nodeValue;\n                        }\n\n                        if (isCompatible) {\n                            curToNodeChild = toNextSibling;\n                            curFromNodeChild = fromNextSibling;\n                            continue outer;\n                        }\n                    }\n\n                    // No compatible match so remove the old node from the DOM\n                    // and continue trying to find a match in the original DOM\n                    removeNode(curFromNodeChild, fromEl, alreadyVisited);\n                    curFromNodeChild = fromNextSibling;\n                }\n\n                if (curToNodeId) {\n                    if ((savedEl = savedEls[curToNodeId])) {\n                        morphEl(savedEl, curToNodeChild, true);\n                        // We want to append the saved element instead\n                        curToNodeChild = savedEl;\n                    } else {\n                        // The current DOM element in the target tree has an ID\n                        // but we did not find a match in any of the\n                        // corresponding siblings. We just put the target\n                        // element in the old DOM tree but if we later find an\n                        // element in the old DOM tree that has a matching ID\n                        // then we will replace the target element with the\n                        // corresponding old element and morph the old element\n                        unmatchedEls[curToNodeId] = curToNodeChild;\n                    }\n                }\n\n                // If we got this far then we did not find a candidate match for\n                // our \"to node\" and we exhausted all of the children \"from\"\n                // nodes. Therefore, we will just append the current \"to node\"\n                // to the end\n                if (onBeforeNodeAdded(curToNodeChild) !== false) {\n                    fromEl.appendChild(curToNodeChild);\n                    onNodeAdded(curToNodeChild);\n                }\n\n                if (curToNodeChild.nodeType === Node.ELEMENT_NODE &&\n                    (curToNodeId || curToNodeChild.firstChild)) {\n                    // The element that was just added to the original DOM may\n                    // have some nested elements with a key/ID that needs to be\n                    // matched up with other elements. We'll add the element to\n                    // a list so that we can later process the nested elements\n                    // if there are any unmatched keyed elements that were\n                    // discarded\n                    movedEls.push(curToNodeChild);\n                }\n\n                curToNodeChild = toNextSibling;\n                curFromNodeChild = fromNextSibling;\n            }\n\n            // We have processed all of the \"to nodes\". If curFromNodeChild is\n            // non-null then we still have some from nodes left over that need\n            // to be removed\n            while (curFromNodeChild) {\n                fromNextSibling = curFromNodeChild.nextSibling;\n                removeNode(curFromNodeChild, fromEl, alreadyVisited);\n                curFromNodeChild = fromNextSibling;\n            }\n        }\n\n        var specialElHandler = specialElHandlers[fromEl.nodeName];\n        if (specialElHandler) {\n            specialElHandler(fromEl, toEl);\n        }\n    } // END: morphEl(...)\n\n    var morphedNode = fromNode;\n    var morphedNodeType = morphedNode.nodeType;\n    var toNodeType = toNode.nodeType;\n\n    if (!childrenOnly) {\n        // Handle the case where we are given two DOM nodes that are not\n        // compatible (e.g. <div> --> <span> or <div> --> TEXT)\n        if (morphedNodeType === Node.ELEMENT_NODE) {\n            if (toNodeType === Node.ELEMENT_NODE) {\n                if (!compareNodeNames(fromNode, toNode)) {\n                    onNodeDiscarded(fromNode);\n                    morphedNode = moveChildren(fromNode, createElement(toNode.nodeName, toNode.namespaceURI));\n                }\n            } else {\n                // Going from an element node to a text node\n                morphedNode = toNode;\n            }\n        } else if (morphedNodeType === Node.TEXT_NODE) { // Text node\n            if (toNodeType === Node.TEXT_NODE) {\n                morphedNode.nodeValue = toNode.nodeValue;\n                return morphedNode;\n            } else {\n                // Text node to something else\n                morphedNode = toNode;\n            }\n        }\n    }\n\n    if (morphedNode === toNode) {\n        // The \"to node\" was not compatible with the \"from node\" so we had to\n        // toss out the \"from node\" and use the \"to node\"\n        onNodeDiscarded(fromNode);\n    } else {\n        morphEl(morphedNode, toNode, false, childrenOnly);\n\n        /**\n         * What we will do here is walk the tree for the DOM element that was\n         * moved from the target DOM tree to the original DOM tree and we will\n         * look for keyed elements that could be matched to keyed elements that\n         * were earlier discarded.  If we find a match then we will move the\n         * saved element into the final DOM tree.\n         */\n        var handleMovedEl = function(el) {\n            var curChild = el.firstChild;\n            while (curChild) {\n                var nextSibling = curChild.nextSibling;\n\n                var key = getNodeKey(curChild);\n                if (key) {\n                    var savedEl = savedEls[key];\n                    if (savedEl && compareNodeNames(curChild, savedEl)) {\n                        curChild.parentNode.replaceChild(savedEl, curChild);\n                        // true: already visited the saved el tree\n                        morphEl(savedEl, curChild, true);\n                        curChild = nextSibling;\n                        if (empty(savedEls)) {\n                            return false;\n                        }\n                        continue;\n                    }\n                }\n\n                if (curChild.nodeType === Node.ELEMENT_NODE) {\n                    handleMovedEl(curChild);\n                }\n\n                curChild = nextSibling;\n            }\n        };\n\n        // The loop below is used to possibly match up any discarded\n        // elements in the original DOM tree with elemenets from the\n        // target tree that were moved over without visiting their\n        // children\n        if (!empty(savedEls)) {\n            handleMovedElsLoop:\n            while (movedEls.length) {\n                var movedElsTemp = movedEls;\n                movedEls = [];\n                for (var i=0; i<movedElsTemp.length; i++) {\n                    if (handleMovedEl(movedElsTemp[i]) === false) {\n                        // There are no more unmatched elements so completely end\n                        // the loop\n                        break handleMovedElsLoop;\n                    }\n                }\n            }\n        }\n\n        // Fire the \"onNodeDiscarded\" event for any saved elements\n        // that never found a new home in the morphed DOM\n        for (var savedElId in savedEls) {\n            if (savedEls.hasOwnProperty(savedElId)) {\n                var savedEl = savedEls[savedElId];\n                onNodeDiscarded(savedEl);\n                walkDiscardedChildNodes(savedEl);\n            }\n        }\n    }\n\n    if (!childrenOnly && morphedNode !== fromNode && fromNode.parentNode) {\n        // If we had to swap out the from node with a new node because the old\n        // node was not compatible with the target node then we need to\n        // replace the old DOM node in the original DOM tree. This is only\n        // possible if the original DOM node was part of a DOM tree which\n        // we know is the case if it has a parent node.\n        fromNode.parentNode.replaceChild(morphedNode, fromNode);\n    }\n\n    return morphedNode;\n}\n\nmodule.exports = morphdom;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/morphdom/lib/index.js\n ** module id = 13\n ** module chunks = 0\n **/","var prefix = 't-';\n\nvar T = {\n  PREFIX: prefix\n};\n\nT.AS = prefix + 'as';\nT.EACH = prefix + 'each';\nT.ELSE = prefix + 'else';\nT.FOREACH = prefix + 'foreach';\nT.IF = prefix + 'if';\nT.SKIP = prefix + 'skip';\nT.TEXT = prefix + 'text';\nT.WITH = prefix + 'with';\n\nmodule.exports.T = T;\n\nmodule.exports.CONTROL_ATTRS = [\n  'as',\n  'each',\n  'else',\n  'foreach',\n  'if',\n  'skip',\n  'text',\n  'with'\n];\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/constants.js\n ** module id = 14\n ** module chunks = 0\n **/","var constants = require('./constants');\nvar T_PREFIX = constants.T.PREFIX;\nvar CONTROL_ATTRS = constants.CONTROL_ATTRS;\n\nvar ns = require('./ns');\nvar util = require('./util');\nvar defined = util.defined;\n\nmodule.exports.getAttributeMap = function(node) {\n  var map = {};\n  var attrs = node.attributes;\n  for (var i = 0; i < attrs.length; i++) {\n    var attr = attrs[i];\n    var name = ns.qualify(attr.name);\n    var localName = name.localName;\n    var value = attr.value;\n    if (localName.indexOf(T_PREFIX) === 0) {\n      localName = localName.substr(T_PREFIX.length);\n      if (CONTROL_ATTRS.indexOf(localName) > -1) {\n        continue;\n      }\n      value = util.compileExpression(value);\n    }\n    var qname = name.prefix\n      ? name.prefix + ':' + localName\n      : localName;\n    map[qname] = value;\n  }\n  return map;\n};\n\nmodule.exports.interpolateAttributes = function(attrMap, data) {\n  var attrs = {};\n  for (var key in attrMap) {\n    if (!attrMap.hasOwnProperty(key)) {\n      continue;\n    }\n    var value = attrMap[key];\n    // only apply functions for attrs that aren't event handlers\n    if (typeof value === 'function' && key.indexOf('on') !== 0) {\n      value = value.call(this, data, key);\n    }\n    if (defined(value)) {\n      attrs[key] = value;\n    }\n  }\n  return attrs;\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/attrs.js\n ** module id = 15\n ** module chunks = 0\n **/","module.exports.getPreviousSibling = function(node, selector) {\n  // eslint-disable-next-line no-cond-assign\n  while (node = node.previousSibling) {\n    if (!node) break;\n    // FIXME this needs a vendor prefix in IE 9+\n    // <http://caniuse.com/#search=matches>\n    if (node.nodeType === 1 && node.matches(selector)) {\n      return node;\n    }\n  }\n  throw new Error('no previous sibling found matching: ' + selector);\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/dom.js\n ** module id = 16\n ** module chunks = 0\n **/","var renderEach = function(fn, render, symbol) {\n  return function(data) {\n    var values = fn.call(this, data);\n    return forEach.call(this, values, render, symbol);\n  };\n};\n\nvar renderWith = function(fn, render, symbol) {\n  render = symbolSetter(symbol, render);\n  return function(data) {\n    data = fn.call(this, data);\n    return render.call(this, data);\n  };\n};\n\nvar forEach = function(data, fn, symbol) {\n  var iterate = symbol\n    ? symbolSetter(symbol, fn)\n    : fn;\n\n  var result = [];\n  var INDEX = '$i';\n  var each = function(d, i) {\n    this[INDEX] = i;\n    result.push(iterate.call(this, d));\n    delete this[INDEX];\n  };\n\n  if (typeof data === 'object') {\n    if (Array.isArray(data)) {\n      data.forEach(each, this);\n    } else {\n      var i = 0;\n      for (var key in data) {\n        if (data.hasOwnProperty(key)) {\n          each.call(this, {key: key, value: data[key]}, i++);\n        }\n      }\n    }\n  } else if (typeof data === 'string') {\n    data.split('').forEach(each, this);\n  }\n\n  return result;\n};\n\nvar symbolSetter = function(symbol, fn) {\n  return function(data) {\n    var previous = set(this, symbol, data);\n    var result = fn.call(this, data);\n    set(this, symbol, previous);\n    return result;\n  };\n};\n\nvar set = function(context, symbol, value) {\n  var previous = context[symbol];\n  if (value === undefined) {\n    delete context[symbol];\n  } else {\n    context[symbol] = value;\n  }\n  return previous;\n};\n\nmodule.exports = {\n  renderWith: renderWith,\n  renderEach: renderEach,\n  symbolSetter: symbolSetter\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/scope.js\n ** module id = 17\n ** module chunks = 0\n **/"],"sourceRoot":""}